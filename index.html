<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>マイク入力 波形＋音響スペクトル</title>
  <style>
    :root{
      --bg:#ffffff; --fg:#111111; --muted:#666;
      --panel:#f4f5f7; --border:#d7dbe0;
      --accent:#1e66ff; --accent2:#ff2d55;
      --grid: rgba(0,0,0,.08);
      --overlay: rgba(30,102,255,.18);
      --overlayBorder: rgba(30,102,255,.7);
      --btn:#ffffff; --btnfg:#111; --btnbd:#cfd6dd;
      --shadow: rgba(0,0,0,.06);
      --deltaBg: rgba(127,127,127,.10);
      --deltaBd: rgba(127,127,127,.25);
    }
    [data-theme="dark"]{
      --bg:#0b0c10; --fg:#f2f3f5; --muted:#a9b0ba;
      --panel:#141720; --border:#2a3240;
      --grid: rgba(255,255,255,.10);
      --overlay: rgba(110,170,255,.18);
      --overlayBorder: rgba(110,170,255,.75);
      --btn:#10131a; --btnfg:#f2f3f5; --btnbd:#2a3240;
      --shadow: rgba(0,0,0,.35);
      --deltaBg: rgba(255,255,255,.08);
      --deltaBd: rgba(255,255,255,.18);
    }
    *{box-sizing:border-box}
    body{
      margin:0; background:var(--bg); color:var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Sans", "Noto Sans JP", sans-serif;
    }
    .app{
      max-width: 1280px; margin: 0 auto; padding: 12px;
      display:flex; flex-direction:column; gap:10px;
    }
    .topbar{
      background:var(--panel); border:1px solid var(--border); border-radius:12px;
      padding:10px; display:flex; flex-wrap:wrap; gap:10px; align-items:center;
      box-shadow: 0 2px 12px var(--shadow);
    }
    .group{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    .spacer{flex:1}
    button, select, input[type="number"]{
      background:var(--btn); color:var(--btnfg);
      border:1px solid var(--btnbd); border-radius:10px;
      padding:8px 10px; font-size:14px; line-height:1;
      box-shadow: 0 1px 6px var(--shadow);
    }
    button{cursor:pointer}
    button:disabled{opacity:.5; cursor:not-allowed}
    button.primary{
      border-color: transparent; background: var(--accent); color: #fff;
    }
    button.danger{
      border-color: transparent; background: var(--accent2); color:#fff;
    }
    .seg{
      display:flex; border:1px solid var(--btnbd); border-radius:12px; overflow:hidden;
      box-shadow: 0 1px 6px var(--shadow);
    }
    .seg button{
      border:none; border-right:1px solid var(--btnbd);
      border-radius:0; box-shadow:none; padding:9px 12px;
      background:var(--btn); color:var(--btnfg);
    }
    .seg button:last-child{border-right:none}
    .seg button.active{
      background: var(--accent); color:#fff;
    }

    .content{
      display:flex; flex-direction:column; gap:10px;
    }
    .dual{
      display:flex; gap:10px; align-items:stretch;
      flex-direction:column;
    }
    @media (min-width: 980px){
      .dual.row{flex-direction:row}
    }

    .panel{
      background:var(--panel); border:1px solid var(--border);
      border-radius:12px; padding:10px;
      box-shadow: 0 2px 12px var(--shadow);
      display:flex; flex-direction:column; gap:8px;
      min-width: 0;
    }
    .panelHeader{
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
    }
    .panelHeader h2{
      margin:0; font-size:16px; font-weight:700;
    }
    .panelHeader .controls{
      margin-left:auto;
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
    }
    .controlRow{
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
    }
    label{font-size:13px; color:var(--muted)}
    input[type="range"]{width: 190px}
    .canvasWrap{
      position:relative; width:100%;
      border:1px solid var(--border); border-radius:12px;
      overflow:hidden; background:var(--bg);
      touch-action: none; /* we handle gestures */
      user-select: none;
      -webkit-user-select: none;
    }
    canvas{display:block; width:100%; height:320px}
    .big canvas{height:520px}
    .overlayRect{
      position:absolute; inset:0; pointer-events:none;
    }
    .infoBubble{
      position:absolute;
      background: rgba(0,0,0,.78);
      color:#fff; padding:6px 8px; border-radius:10px;
      font-size:12px; white-space:nowrap;
      transform: translate(10px, -10px);
      pointer-events:none;
      display:none;
      max-width: 80%;
    }
    [data-theme="dark"] .infoBubble{
      background: rgba(255,255,255,.12);
      border: 1px solid rgba(255,255,255,.18);
    }
    .footer{
      display:flex; flex-direction:column; gap:6px;
      padding-top:2px;
    }
    .delta{
      font-size:18px; font-weight:900;
      letter-spacing:.2px;
      color: var(--fg);
      background: var(--deltaBg);
      border: 1px solid var(--deltaBd);
      padding: 8px 10px;
      border-radius: 12px;
    }
    .small{
      font-size:13px; color:var(--muted); line-height:1.35;
    }
    .status{
      padding:10px;
      background: var(--panel); border:1px solid var(--border);
      border-radius:12px;
      box-shadow: 0 2px 12px var(--shadow);
    }
    .pill{
      display:inline-block; padding:2px 8px; border-radius:999px;
      border:1px solid var(--border); margin-right:6px;
      font-size:12px; color:var(--muted);
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      padding:1px 6px; border-radius:7px;
      border:1px solid var(--border);
      background: rgba(127,127,127,.12);
      color: var(--fg);
      margin: 0 2px;
    }
  </style>
</head>
<body>
<div class="app" id="app" data-theme="light">
  <!-- TOP BAR -->
  <div class="topbar">
    <div class="group">
      <button id="btnStart" class="primary">Start</button>
      <button id="btnPause">Pause</button>
      <button id="btnReset" class="danger">Reset</button>
    </div>

    <div class="group">
      <div class="seg" aria-label="表示切替">
        <button id="tabBoth" class="active">同時表示</button>
        <button id="tabWave">波形のみ</button>
        <button id="tabSpec">音響スペクトルのみ</button>
      </div>
    </div>

    <div class="group">
      <button id="btnMode">2点選択へ</button>
      <button id="btnTheme">ダークへ</button>
    </div>

    <div class="spacer"></div>

    <div class="group">
      <span class="pill" id="pillState">停止中</span>
      <span class="pill" id="pillHint">ショートカット: <span class="kbd">S</span><span class="kbd">P</span><span class="kbd">R</span><span class="kbd">Z</span><span class="kbd">W</span><span class="kbd">F</span><span class="kbd">B</span><span class="kbd">V</span><span class="kbd">Esc</span></span>
    </div>
  </div>

  <div class="content">
    <div id="dual" class="dual row">
      <!-- WAVE -->
      <section id="panelWave" class="panel">
        <div class="panelHeader">
          <h2>波形</h2>
          <div class="controls">
            <div class="controlRow">
              <label for="waveWinRange">波形時間窓（N秒）</label>
              <input id="waveWinRange" type="range" min="0.05" max="1.0" step="0.01" value="1.0" />
              <input id="waveWinNum" type="number" min="0.05" max="1.0" step="0.01" value="1.0" style="width:86px" />
            </div>

            <div class="controlRow">
              <label for="waveGainRange">縦軸倍率</label>
              <input id="waveGainRange" type="range" min="0.2" max="20" step="0.1" value="1.0" />
              <input id="waveGainNum" type="number" min="0.2" max="20" step="0.1" value="1.0" style="width:86px" />
            </div>

            <div class="controlRow">
              <button id="btnWaveABClear">A/B解除</button>
              <button id="btnWaveCSV" disabled>CSV</button>
            </div>
          </div>
        </div>

        <div class="canvasWrap" id="wrapWave" aria-label="波形キャンバス">
          <canvas id="cvWave" width="1200" height="360"></canvas>
          <canvas class="overlayRect" id="ovWave" width="1200" height="360"></canvas>
          <div class="infoBubble" id="bubbleWave"></div>
        </div>

        <div class="footer">
          <div class="delta" id="deltaWave">Δ: —</div>
          <div class="small" id="descWave">
            状態：<span id="waveStateText">停止中</span> / Pause中のみズーム・2点選択が有効（ただしズームリセットは常に有効）。縦軸倍率は測定中でも変更できます。
          </div>
        </div>
      </section>

      <!-- SPECTRUM -->
      <section id="panelSpec" class="panel">
        <div class="panelHeader">
          <h2>音響スペクトル</h2>
          <div class="controls">
            <div class="controlRow">
              <label for="fftSel">FFTサイズ</label>
              <select id="fftSel">
                <option>1024</option><option>2048</option><option>4096</option>
                <option selected>8192</option>
                <option>16384</option><option>32768</option>
              </select>

              <button id="btnSpecYAxis">縦軸：規格化</button>
              <button id="btnSpecABClear">A/B解除</button>
              <button id="btnSpecCSV" disabled>CSV</button>
            </div>

            <div class="controlRow">
              <label>スペクトル周波数　最小:</label>
              <select id="minPreset">
                <option>0</option><option>20</option><option>100</option>
                <option selected>200</option><option>300</option><option>400</option>
                <option>500</option><option>1000</option><option value="custom">任意入力</option>
              </select>
              <input id="minHz" type="number" min="0" step="1" value="200" style="width:90px" />
              <label>最大:</label>
              <select id="maxPreset">
                <option>1000</option><option selected>1500</option><option>2000</option>
                <option>5000</option><option>10000</option><option>20000</option>
                <option value="custom">任意入力</option>
              </select>
              <input id="maxHz" type="number" min="1" step="1" value="1500" style="width:90px" />
            </div>
          </div>
        </div>

        <div class="canvasWrap" id="wrapSpec" aria-label="スペクトルキャンバス">
          <canvas id="cvSpec" width="1200" height="360"></canvas>
          <canvas class="overlayRect" id="ovSpec" width="1200" height="360"></canvas>
          <div class="infoBubble" id="bubbleSpec"></div>
        </div>

        <div class="footer">
          <div class="delta" id="deltaSpec">Δ: —</div>
          <div class="small" id="descSpec">
            状態：<span id="specStateText">停止中</span> / Pause中はスペクトルをスナップショット固定（クリック・ドラッグで値が変化しません）。
          </div>
        </div>
      </section>
    </div>

    <!-- Explanation / status below ALL graphs -->
    <div class="status">
      <div class="small" id="statusLine">
        <b>注意：</b>このアプリは <b>HTTPS</b> または <b>localhost</b> 上でのみマイクが使えます（file:// 直開きだと動かないことがあります）。マイク許可を拒否した場合は取得できません。
      </div>
      <div class="small" id="helpLine" style="margin-top:6px">
        <b>操作メモ：</b>
        Startでマイク開始 / Pauseで表示停止（データ保持）/ Resetで完全初期化。
        Pause中はドラッグでズーム、<span class="kbd">Z</span>で2点選択へ切替。<span class="kbd">Esc</span>でカーソル情報・A/B解除。
        CSVはPause中のみ（<span class="kbd">V</span>）。
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ---------- Utilities ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a,b,t) => a + (b-a)*t;
  const nice125 = (raw) => {
    const p = Math.pow(10, Math.floor(Math.log10(raw)));
    const n = raw / p;
    let m = 1;
    if (n <= 1) m = 1;
    else if (n <= 2) m = 2;
    else if (n <= 5) m = 5;
    else m = 10;
    return m * p;
  };
  const formatHz = (hz) => (hz >= 1000) ? (hz/1000).toFixed(hz%1000===0?0:1)+"k" : String(Math.round(hz));
  const nowTs = () => new Date().toISOString().replace(/[:.]/g,'-');

  function isTextInputFocused(){
    const el = document.activeElement;
    if (!el) return false;
    const tag = el.tagName?.toLowerCase();
    return tag === 'input' || tag === 'select' || tag === 'textarea' || el.isContentEditable;
  }

  // ---------- DOM ----------
  const app = document.getElementById('app');
  const dual = document.getElementById('dual');
  const panelWave = document.getElementById('panelWave');
  const panelSpec = document.getElementById('panelSpec');

  const btnStart = document.getElementById('btnStart');
  const btnPause = document.getElementById('btnPause');
  const btnReset = document.getElementById('btnReset');

  const tabBoth = document.getElementById('tabBoth');
  const tabWave = document.getElementById('tabWave');
  const tabSpec = document.getElementById('tabSpec');

  const btnMode = document.getElementById('btnMode');
  const btnTheme = document.getElementById('btnTheme');

  const pillState = document.getElementById('pillState');

  const waveWinRange = document.getElementById('waveWinRange');
  const waveWinNum   = document.getElementById('waveWinNum');
  const waveGainRange = document.getElementById('waveGainRange');
  const waveGainNum   = document.getElementById('waveGainNum');

  const fftSel = document.getElementById('fftSel');
  const btnSpecYAxis = document.getElementById('btnSpecYAxis');
  const minPreset = document.getElementById('minPreset');
  const maxPreset = document.getElementById('maxPreset');
  const minHzIn = document.getElementById('minHz');
  const maxHzIn = document.getElementById('maxHz');

  const btnWaveABClear = document.getElementById('btnWaveABClear');
  const btnSpecABClear = document.getElementById('btnSpecABClear');
  const btnWaveCSV = document.getElementById('btnWaveCSV');
  const btnSpecCSV = document.getElementById('btnSpecCSV');

  const cvWave = document.getElementById('cvWave');
  const ovWave = document.getElementById('ovWave');
  const wrapWave = document.getElementById('wrapWave');
  const bubbleWave = document.getElementById('bubbleWave');

  const cvSpec = document.getElementById('cvSpec');
  const ovSpec = document.getElementById('ovSpec');
  const wrapSpec = document.getElementById('wrapSpec');
  const bubbleSpec = document.getElementById('bubbleSpec');

  const deltaWave = document.getElementById('deltaWave');
  const deltaSpec = document.getElementById('deltaSpec');

  const waveStateText = document.getElementById('waveStateText');
  const specStateText = document.getElementById('specStateText');

  // ---------- App State ----------
  const State = { STOPPED:'stopped', RUNNING:'running', PAUSED:'paused' };
  const Mode  = { ZOOM:'zoom', PICK:'pick' };

  let appState = State.STOPPED;
  let mode = Mode.ZOOM;

  // Theme
  let theme = 'light';

  // View
  let view = 'both';

  // Audio
  let audioCtx = null;
  let mediaStream = null;
  let sourceNode = null;
  let analyser = null;
  let workletNode = null;
  let sampleRate = 48000;

  // Ring buffer (waveform)
  const RB_SECONDS = 6;
  let ring = null;
  let ringLen = 0;
  let ringWrite = 0;
  let ringCount = 0;

  // Snapshots for PAUSE
  let snapWave = null;         // Float32Array (raw)
  let snapWaveStartCount = 0;
  let snapSpec = null;         // Float32Array (already in current yMode: norm=>0..100, db=>dB)
  let snapSpecMeta = null;

  // FFT / spectrum
  let fftSize = 8192;
  let yMode = 'norm'; // norm | db
  let freqBins = null;
  let freqBinsByte = null;
  let specPeaks = [];

  // Wave window + display gain
  let waveWindowSec = 1.0;
  let waveGain = 1.0;

  // Zoom states
  const waveZoom = { active:false, x0:0, x1:1, y0:-1, y1:1 };
  const specZoom = { active:false, x0:200, x1:1500 };

  // Cursor + A/B (store RAW for wave; store current-mode value for spec)
  const cursorWave = {active:false, tms:0, raw:0};
  const cursorSpec = {active:false, hz:0, val:0};

  const ABWave = {A:null, B:null}; // {tms, raw}
  const ABSpec = {A:null, B:null}; // {hz, val}

  // Interaction
  let rafId = 0;

  const drag = {
    active:false,
    kind:null,   // 'zoom' | 'pan'
    target:null, // 'wave' | 'spec'
    ptrId:null,
    x0:0, y0:0, x1:0, y1:0,
    shift:false,
  };

  // Touch gesture (pinch / pan)
  const pointers = new Map(); // id -> {x,y}
  let gesture = null;         // {target, startDist, startCenter, startWaveZoom, startSpecZoom}

  // ---------- Canvas Setup ----------
  function resizeCanvases(){
    const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    for (const [wrap, cv, ov] of [[wrapWave, cvWave, ovWave],[wrapSpec, cvSpec, ovSpec]]){
      const rect = wrap.getBoundingClientRect();
      const w = Math.max(320, Math.floor(rect.width));
      const h = Math.max(220, Math.floor(rect.height));
      cv.width = Math.floor(w * dpr);
      cv.height = Math.floor(h * dpr);
      cv.style.width = w+'px';
      cv.style.height = h+'px';
      ov.width = cv.width;
      ov.height = cv.height;
      ov.style.width = cv.style.width;
      ov.style.height = cv.style.height;
    }
  }
  window.addEventListener('resize', () => { resizeCanvases(); drawOnce(); });

  // ---------- View / Layout ----------
  function setView(v){
    view = v;
    tabBoth.classList.toggle('active', v==='both');
    tabWave.classList.toggle('active', v==='wave');
    tabSpec.classList.toggle('active', v==='spec');

    panelWave.style.display = (v==='spec') ? 'none' : '';
    panelSpec.style.display = (v==='wave') ? 'none' : '';

    panelWave.classList.toggle('big', v==='wave');
    panelSpec.classList.toggle('big', v==='spec');

    dual.classList.toggle('row', v==='both');

    resizeCanvases();
    drawOnce();
  }
  tabBoth.addEventListener('click', () => setView('both'));
  tabWave.addEventListener('click', () => setView('wave'));
  tabSpec.addEventListener('click', () => setView('spec'));

  // ---------- Theme ----------
  function setTheme(t){
    theme = t;
    app.setAttribute('data-theme', t);
    btnTheme.textContent = (t==='light') ? 'ダークへ' : 'ライトへ';
    drawOnce();
  }
  btnTheme.addEventListener('click', () => setTheme(theme==='light' ? 'dark' : 'light'));

  // ---------- Mode toggle (show "switch-to") ----------
  function setMode(m){
    mode = m;
    btnMode.textContent = (m===Mode.ZOOM) ? '2点選択へ' : 'ズームへ';
    // ドラッグと2点選択が競合しないよう、PICK中はドラッグ開始を一切しない
    drag.active = false;
    clearOverlay('wave'); clearOverlay('spec');
  }
  btnMode.addEventListener('click', () => setMode(mode===Mode.ZOOM ? Mode.PICK : Mode.ZOOM));

  // ---------- Controls: waveform window ----------
  function setWaveWindow(sec){
    sec = clamp(sec, 0.05, 1.0);
    waveWindowSec = sec;
    waveWinRange.value = sec.toFixed(2);
    waveWinNum.value = sec.toFixed(2);

    if (waveZoom.active){
      waveZoom.x0 = clamp(waveZoom.x0, 0, waveWindowSec);
      waveZoom.x1 = clamp(waveZoom.x1, 0, waveWindowSec);
      if (Math.abs(waveZoom.x1 - waveZoom.x0) < 1e-6) resetWaveZoom();
    } else {
      waveZoom.x0 = 0; waveZoom.x1 = waveWindowSec;
    }

    if (appState === State.PAUSED){
      snapWave = getWaveWindowFromRing();
    }
    drawOnce();
  }
  waveWinRange.addEventListener('input', () => setWaveWindow(parseFloat(waveWinRange.value)));
  waveWinNum.addEventListener('change', () => setWaveWindow(parseFloat(waveWinNum.value)));

  // ---------- Controls: waveform gain (RUNNINGでもOK) ----------
  function setWaveGain(g){
    g = clamp(g, 0.2, 20);
    waveGain = g;
    waveGainRange.value = g.toFixed(1);
    waveGainNum.value = g.toFixed(1);
    updateDeltas();
    drawOnce();
  }
  waveGainRange.addEventListener('input', () => setWaveGain(parseFloat(waveGainRange.value)));
  waveGainNum.addEventListener('change', () => setWaveGain(parseFloat(waveGainNum.value)));

  // ---------- Spectrum controls ----------
  function setFFTSize(n){
    fftSize = n|0;
    if (analyser) analyser.fftSize = fftSize;
    if (analyser){
      freqBins = new Float32Array(analyser.frequencyBinCount);
      freqBinsByte = new Uint8Array(analyser.frequencyBinCount);
    }
    snapSpec = null;
    snapSpecMeta = null;
    if (appState === State.PAUSED) captureSpectrumSnapshot();
    drawOnce();
  }
  fftSel.addEventListener('change', () => setFFTSize(parseInt(fftSel.value,10)));

  function setSpecRange(minHz, maxHz){
    minHz = Math.max(0, Math.floor(minHz));
    maxHz = Math.max(minHz+1, Math.floor(maxHz));
    const nyq = sampleRate/2;
    maxHz = Math.min(maxHz, Math.floor(nyq));
    specZoom.active = false;
    specZoom.x0 = minHz;
    specZoom.x1 = maxHz;
    minHzIn.value = String(minHz);
    maxHzIn.value = String(maxHz);

    if (appState === State.PAUSED) captureSpectrumSnapshot();
    drawOnce();
  }

  minPreset.addEventListener('change', () => {
    if (minPreset.value !== 'custom') setSpecRange(parseFloat(minPreset.value), parseFloat(maxHzIn.value));
    else minHzIn.focus();
  });
  maxPreset.addEventListener('change', () => {
    if (maxPreset.value !== 'custom') setSpecRange(parseFloat(minHzIn.value), parseFloat(maxPreset.value));
    else maxHzIn.focus();
  });
  minHzIn.addEventListener('change', () => setSpecRange(parseFloat(minHzIn.value), parseFloat(maxHzIn.value)));
  maxHzIn.addEventListener('change', () => setSpecRange(parseFloat(minHzIn.value), parseFloat(maxHzIn.value)));

  function setYAxisMode(next){
    yMode = next;
    btnSpecYAxis.textContent = (yMode==='norm') ? '縦軸：規格化' : '縦軸：dB';
    // 縦軸変更は「表示」「ピーク」「A/B・Δ」「CSV」すべて連動させるため、Pause中はスナップショットを取り直す
    if (appState === State.PAUSED) {
      // A/Bは旧モード値のままだと混乱するので、ここは自動解除（授業向け事故防止）
      ABSpec.A = ABSpec.B = null;
      cursorSpec.active = false;
      captureSpectrumSnapshot();
    }
    updateDeltas();
    drawOnce();
  }
  btnSpecYAxis.addEventListener('click', () => setYAxisMode(yMode==='norm' ? 'db' : 'norm'));

  // ---------- Zoom resets (always allowed) ----------
  function resetWaveZoom(){
    waveZoom.active = false;
    waveZoom.x0 = 0; waveZoom.x1 = waveWindowSec;
    waveZoom.y0 = -1; waveZoom.y1 = 1;
  }
  function resetSpecZoom(){
    specZoom.active = false;
    specZoom.x0 = parseFloat(minHzIn.value);
    specZoom.x1 = parseFloat(maxHzIn.value);
  }
  function clearAllCursorsAB(){
    cursorWave.active = false;
    cursorSpec.active = false;
    ABWave.A = ABWave.B = null;
    ABSpec.A = ABSpec.B = null;
    bubbleWave.style.display = 'none';
    bubbleSpec.style.display = 'none';
    updateDeltas();
  }

  // ---------- State UI ----------
  function setAppState(s){
    appState = s;
    const text = (s===State.STOPPED) ? '停止中' : (s===State.RUNNING ? '測定中' : 'Pause中');
    pillState.textContent = text;
    waveStateText.textContent = text;
    specStateText.textContent = text;

    btnPause.textContent = (s===State.PAUSED) ? 'Resume' : 'Pause';
    btnStart.disabled = (s===State.RUNNING || s===State.PAUSED);
    btnPause.disabled = (s===State.STOPPED);
    btnWaveCSV.disabled = !(s===State.PAUSED);
    btnSpecCSV.disabled = !(s===State.PAUSED);

    // 案1：測定中（Start/Resume）になったらズームを自動クリア
    if (s === State.RUNNING){
      resetWaveZoom();
      resetSpecZoom();
      drag.active = false;
      clearOverlay('wave'); clearOverlay('spec');
    }
    drawOnce();
  }

  // ---------- AudioWorklet (single-file) ----------
  async function initAudio(){
    const workletCode = `
      class TapProcessor extends AudioWorkletProcessor {
        process(inputs){
          const input = inputs[0];
          if (!input || input.length === 0) return true;
          const ch0 = input[0];
          if (!ch0) return true;
          this.port.postMessage(ch0.slice(0));
          return true;
        }
      }
      registerProcessor('tap-processor', TapProcessor);
    `;
    const blob = new Blob([workletCode], {type:'application/javascript'});
    const url = URL.createObjectURL(blob);

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    sampleRate = audioCtx.sampleRate;

    ringLen = Math.floor(sampleRate * RB_SECONDS);
    ring = new Float32Array(ringLen);
    ringWrite = 0;
    ringCount = 0;

    await audioCtx.audioWorklet.addModule(url);
    // ※一部環境では revoke で失敗するケースがあるため、ここでは敢えて破棄しない（安全側）
    // URL.revokeObjectURL(url);

    mediaStream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false }
    });

    sourceNode = audioCtx.createMediaStreamSource(mediaStream);

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = fftSize;
    analyser.smoothingTimeConstant = 0;
    freqBins = new Float32Array(analyser.frequencyBinCount);
    freqBinsByte = new Uint8Array(analyser.frequencyBinCount);

    workletNode = new AudioWorkletNode(audioCtx, 'tap-processor');

    const zero = audioCtx.createGain();
    zero.gain.value = 0.0;

    sourceNode.connect(analyser);
    analyser.connect(workletNode);
    workletNode.connect(zero);
    zero.connect(audioCtx.destination);

    workletNode.port.onmessage = (e) => {
      const chunk = e.data;
      if (!chunk || !chunk.length) return;
      writeRing(chunk);
    };
  }

  function writeRing(chunk){
    for (let i=0;i<chunk.length;i++){
      ring[ringWrite] = chunk[i];
      ringWrite = (ringWrite + 1) % ringLen;
      ringCount++;
    }
  }

  // ---------- Snapshot helpers ----------
  function getWaveWindowFromRing(){
    if (!ring) return null;
    const need = Math.floor(sampleRate * waveWindowSec);
    const out = new Float32Array(need);
    let idx = ringWrite - need;
    while (idx < 0) idx += ringLen;
    for (let i=0;i<need;i++){
      out[i] = ring[(idx + i) % ringLen];
    }
    snapWaveStartCount = ringCount - need;
    return out;
  }

  function captureSpectrumSnapshot(){
    if (!analyser) return;
    if (yMode === 'db'){
      analyser.getFloatFrequencyData(freqBins);
      snapSpec = new Float32Array(freqBins);
    } else {
      analyser.getByteFrequencyData(freqBinsByte);
      snapSpec = new Float32Array(freqBinsByte.length);
      for (let i=0;i<freqBinsByte.length;i++){
        snapSpec[i] = (freqBinsByte[i] / 255) * 100;
      }
    }
    snapSpecMeta = {
      fftSize,
      minHz: parseFloat(minHzIn.value),
      maxHz: parseFloat(maxHzIn.value),
      yMode
    };
  }

  // ---------- Start / Pause / Reset ----------
  async function start(){
    try{
      await initAudio();
      setAppState(State.RUNNING);
      scheduleDraw();
    }catch(err){
      console.error(err);
      const msg = [
        'マイクを取得できませんでした。',
        '・ブラウザでマイク許可が必要です（拒否した場合は取得できません）。',
        '・このアプリは HTTPS または localhost でのみマイクが使えます（file:// 直開きは不可の場合あり）。',
        'エラー: ' + (err?.message || String(err))
      ].join('\n');
      document.getElementById('statusLine').textContent = msg;
      setAppState(State.STOPPED);
      await hardResetAudio();
    }
  }

  function pauseToggle(){
    if (appState === State.RUNNING){
      snapWave = getWaveWindowFromRing();
      captureSpectrumSnapshot();
      setAppState(State.PAUSED);
      cancelAnimationFrame(rafId); rafId = 0;
      drawOnce();
    } else if (appState === State.PAUSED){
      setAppState(State.RUNNING);
      scheduleDraw();
    }
  }

  async function hardResetAudio(){
    cancelAnimationFrame(rafId); rafId = 0;

    if (mediaStream){
      for (const tr of mediaStream.getTracks()) tr.stop();
    }
    mediaStream = null;

    try{ sourceNode?.disconnect(); }catch{}
    try{ analyser?.disconnect(); }catch{}
    try{ workletNode?.disconnect(); }catch{}
    sourceNode = null; analyser = null; workletNode = null;

    if (audioCtx){
      try{ await audioCtx.close(); }catch{}
    }
    audioCtx = null;

    ring = null; ringLen = 0; ringWrite = 0; ringCount = 0;
    snapWave = null; snapSpec = null; snapSpecMeta = null;

    resetWaveZoom();
    resetSpecZoom();
    drag.active = false;
    clearAllCursorsAB();
    updateDeltas();

    drawOnce();
  }

  async function resetAll(){
    await hardResetAudio();
    setAppState(State.STOPPED);
    document.getElementById('statusLine').innerHTML =
      '<b>注意：</b>このアプリは <b>HTTPS</b> または <b>localhost</b> 上でのみマイクが使えます（file:// 直開きだと動かないことがあります）。マイク許可を拒否した場合は取得できません。';
  }

  btnStart.addEventListener('click', start);
  btnPause.addEventListener('click', pauseToggle);
  btnReset.addEventListener('click', resetAll);

  // ---------- Keyboard shortcuts ----------
  window.addEventListener('keydown', (e) => {
    if (isTextInputFocused()) return;

    const k = e.key.toLowerCase();
    if (k === 's'){ e.preventDefault(); if (appState === State.STOPPED) start(); }
    else if (k === 'p'){ e.preventDefault(); if (appState !== State.STOPPED) pauseToggle(); }
    else if (k === 'r'){ e.preventDefault(); resetAll(); }
    else if (k === 'z'){ e.preventDefault(); setMode(mode===Mode.ZOOM ? Mode.PICK : Mode.ZOOM); }
    else if (k === 'w'){ e.preventDefault(); setView('wave'); }
    else if (k === 'f'){ e.preventDefault(); setView('spec'); }
    else if (k === 'b'){ e.preventDefault(); setView('both'); }
    else if (k === 'v'){ e.preventDefault(); if (appState===State.PAUSED) { downloadCSVWave(); downloadCSVSpec(); } }
    else if (k === 'escape'){ e.preventDefault(); escClear(); }
  });

  // ---------- CSV ----------
  function downloadCSVWave(){
    if (appState !== State.PAUSED) return;
    const data = getWaveDisplayData();
    if (!data) return;

    const {rawSamples, dtms, x0ms, x1ms} = data;

    const lines = [];
    lines.push(`# kind: waveform`);
    lines.push(`# sampleRate: ${sampleRate}`);
    lines.push(`# windowSec: ${waveWindowSec}`);
    lines.push(`# waveGain: ${waveGain}`);
    lines.push(`# zoomX_ms: ${x0ms.toFixed(3)}..${x1ms.toFixed(3)}`);
    lines.push(`# zoomY_raw: ${waveZoom.active ? `${waveZoom.y0.toFixed(6)}..${waveZoom.y1.toFixed(6)}` : `-1..1`}`);
    lines.push(`t_ms,amp`);

    const startIndex = Math.max(0, Math.floor(x0ms / dtms));
    const endIndex = Math.min(rawSamples.length-1, Math.ceil(x1ms / dtms));

    for (let i=startIndex;i<=endIndex;i++){
      const t = i*dtms;
      const amp = rawSamples[i] * waveGain; // 表示に合わせる
      lines.push(`${t.toFixed(6)},${amp.toFixed(8)}`);
    }
    saveText(lines.join('\n'), `waveform_${nowTs()}.csv`);
  }

  function downloadCSVSpec(){
    if (appState !== State.PAUSED) return;
    const spec = getSpectrumDisplayData();
    if (!spec) return;

    const lines = [];
    const minHz = parseFloat(minHzIn.value);
    const maxHz = parseFloat(maxHzIn.value);
    lines.push(`# kind: spectrum`);
    lines.push(`# sampleRate: ${sampleRate}`);
    lines.push(`# fftSize: ${fftSize}`);
    lines.push(`# freqRangeHz: ${minHz}..${maxHz}`);
    lines.push(`# yMode: ${yMode}`);
    lines.push(`# zoomX_Hz: ${spec.x0.toFixed(3)}..${spec.x1.toFixed(3)}`);
    lines.push(`f_hz,y`);

    const {binHz, yArr, i0, i1} = spec;
    for (let i=i0;i<=i1;i++){
      const f = i*binHz;
      const y = yArr[i];
      lines.push(`${f.toFixed(6)},${y.toFixed(6)}`);
    }
    saveText(lines.join('\n'), `spectrum_${nowTs()}.csv`);
  }

  function saveText(text, filename){
    const blob = new Blob([text], {type:'text/csv;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  btnWaveCSV.addEventListener('click', downloadCSVWave);
  btnSpecCSV.addEventListener('click', downloadCSVSpec);

  // ---------- A/B clear ----------
  function clearAB(which){
    if (which === 'wave'){
      ABWave.A = ABWave.B = null;
      cursorWave.active = false;
      bubbleWave.style.display = 'none';
    } else {
      ABSpec.A = ABSpec.B = null;
      cursorSpec.active = false;
      bubbleSpec.style.display = 'none';
    }
    updateDeltas();
    drawOnce();
  }
  btnWaveABClear.addEventListener('click', () => clearAB('wave'));
  btnSpecABClear.addEventListener('click', () => clearAB('spec'));

  function escClear(){
    clearAllCursorsAB();
    drawOnce();
  }

  // ---------- Drawing ----------
  function scheduleDraw(){
    if (rafId) return;
    const tick = () => {
      rafId = requestAnimationFrame(tick);
      if (appState !== State.RUNNING) return;
      drawAll();
    };
    rafId = requestAnimationFrame(tick);
  }

  function drawOnce(){ drawAll(true); }

  function themeColors(){
    const cs = getComputedStyle(app);
    return {
      bg: cs.getPropertyValue('--bg').trim(),
      fg: cs.getPropertyValue('--fg').trim(),
      muted: cs.getPropertyValue('--muted').trim(),
      grid: cs.getPropertyValue('--grid').trim(),
      accent: cs.getPropertyValue('--accent').trim(),
      accent2: cs.getPropertyValue('--accent2').trim(),
      overlay: cs.getPropertyValue('--overlay').trim(),
      overlayBorder: cs.getPropertyValue('--overlayBorder').trim(),
      border: cs.getPropertyValue('--border').trim(),
    };
  }

  function clearCanvas(ctx, w, h, bg){
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = bg;
    ctx.fillRect(0,0,w,h);
    ctx.restore();
  }

  function drawAll(){
    const c = themeColors();
    drawWave(c);
    drawSpec(c);
  }

  // ----- Ticks -----
  function computeTicks(min, max, targetCount=5){
    const span = max - min;
    if (span <= 0) return [];
    const raw = span / (targetCount-1);
    const step = nice125(raw);
    const start = Math.ceil(min / step) * step;
    const ticks = [];
    for (let v=start; v<=max+1e-9; v+=step) ticks.push(v);
    if (ticks.length === 0 || Math.abs(ticks[0]-min) > step*0.25) ticks.unshift(min);
    if (Math.abs(ticks[ticks.length-1]-max) > step*0.25) ticks.push(max);
    const uniq = [];
    for (const t of ticks){
      if (uniq.length===0 || Math.abs(uniq[uniq.length-1]-t) > step*0.1) uniq.push(t);
    }
    return uniq;
  }

  // ----- Wave data -----
  function getWaveDisplayData(){
    if (!snapWave) return null;
    const rawSamples = snapWave;
    const dtms = 1000 / sampleRate;
    const x0ms = (waveZoom.active ? waveZoom.x0 : 0) * 1000;
    const x1ms = (waveZoom.active ? waveZoom.x1 : waveWindowSec) * 1000;
    return {rawSamples, dtms, x0ms, x1ms};
  }

  function spanDigits(span){
    if (span <= 1) return 3;
    if (span <= 10) return 2;
    if (span <= 100) return 1;
    return 0;
  }

  function drawCursorPoint(ctx, c, x, y){
    ctx.save();
    ctx.fillStyle = c.accent;
    ctx.strokeStyle = c.bg;
    ctx.lineWidth = 2.5 * Math.max(1, (window.devicePixelRatio||1)*0.7);
    ctx.beginPath();
    ctx.arc(x, y, 5 * Math.max(1, (window.devicePixelRatio||1)*0.6), 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  function drawWaveAB(ctx, c, padL, padT, pw, ph, xMin, xMax, yMin, yMax, innerPad){
    ctx.save();
    ctx.strokeStyle = c.accent2;
    ctx.lineWidth = 1.5 * Math.max(1, (window.devicePixelRatio||1)*0.6);

    function mapY(val){
      // y mapping with inner padding
      const phIn = ph - 2*innerPad;
      return padT + innerPad + (1 - (val - yMin)/(yMax-yMin)) * phIn;
    }

    function drawLine(pt){
      const x = padL + (pt.tms - xMin)/(xMax-xMin) * pw;
      ctx.beginPath();
      ctx.moveTo(x, padT);
      ctx.lineTo(x, padT+ph);
      ctx.stroke();

      const yDisp = (pt.raw * waveGain);
      const y = mapY(yDisp);
      ctx.fillStyle = c.accent2;
      ctx.beginPath();
      ctx.arc(x, y, 4.5 * Math.max(1, (window.devicePixelRatio||1)*0.6), 0, Math.PI*2);
      ctx.fill();
    }

    if (ABWave.A) drawLine(ABWave.A);
    if (ABWave.B) drawLine(ABWave.B);
    ctx.restore();
  }

  function drawWave(c){
    const ctx = cvWave.getContext('2d');
    const w = cvWave.width, h = cvWave.height;

    if (appState === State.RUNNING){
      snapWave = getWaveWindowFromRing();
    } else if (appState === State.STOPPED){
      snapWave = null;
    }
    const data = getWaveDisplayData();

    clearCanvas(ctx, w, h, c.bg);

    const padL = 64, padR = 18, padT = 42, padB = 36;
    const pw = w - padL - padR;
    const ph = h - padT - padB;

    ctx.strokeStyle = c.border;
    ctx.lineWidth = 1;
    ctx.strokeRect(padL, padT, pw, ph);

    ctx.strokeStyle = c.grid;
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let i=1;i<5;i++){
      const y = padT + ph * (i/5);
      ctx.moveTo(padL, y); ctx.lineTo(padL+pw, y);
    }
    ctx.stroke();

    // x range (ms)
    const xMin = (waveZoom.active ? waveZoom.x0 : 0) * 1000;
    const xMax = (waveZoom.active ? waveZoom.x1 : waveWindowSec) * 1000;

    // y range: apply gain to zoom-y concept so that cursor/AB align with visual
    // waveZoom.y0/y1 are RAW zoom box; display multiplies by gain
// y軸レンジは「raw基準」で決める（waveGainはここに掛けない）
let yMinDisp = -1;
let yMaxDisp =  1;

if (waveZoom.active){
  const r0 = Math.min(waveZoom.y0, waveZoom.y1);
  const r1 = Math.max(waveZoom.y0, waveZoom.y1);
  if (Math.abs(r1 - r0) > 1e-9){
    yMinDisp = r0;  // ← *waveGainしない
    yMaxDisp = r1;  // ← *waveGainしない
  }
}


    // ticks
    const ticks = computeTicks(xMin, xMax, 5);
    ctx.fillStyle = c.fg;
    ctx.font = `${Math.round(12*(window.devicePixelRatio||1))}px system-ui, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.strokeStyle = c.grid;
    ctx.lineWidth = 1;

    for (const t of ticks){
      const x = padL + (t - xMin) / (xMax - xMin) * pw;
      ctx.beginPath();
      ctx.moveTo(x, padT); ctx.lineTo(x, padT+ph);
      ctx.stroke();
    }
    let lastLabelX = -1e9;
    const minDx = 70 * Math.max(1, (window.devicePixelRatio||1));
    for (const t of ticks){
      const x = padL + (t - xMin) / (xMax - xMin) * pw;
      if (x - lastLabelX < minDx) continue;
      lastLabelX = x;
      const label = `${t.toFixed(spanDigits(xMax-xMin))}`;
      ctx.fillText(label, x, padT - 6);
    }
    ctx.textAlign = 'right';
    ctx.fillText('ms', padL+pw, padT - 6);

    const innerPad = 2 * Math.max(1, (window.devicePixelRatio||1)); // 0%/0線が枠と重ならないための内側余白
    const phIn = ph - 2*innerPad;

    function mapY(valDisp){
      return padT + innerPad + (1 - (valDisp - yMinDisp)/(yMaxDisp-yMinDisp)) * phIn;
    }

    if (!data){
      ctx.fillStyle = c.muted;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.font = `${Math.round(14*(window.devicePixelRatio||1))}px system-ui, sans-serif`;
      ctx.fillText('Startでマイク入力を開始します', padL+pw/2, padT+ph/2);
      drawWaveAB(ctx, c, padL, padT, pw, ph, xMin, xMax, yMinDisp, yMaxDisp, innerPad);
      return;
    }

    // waveform: min/max per pixel (use displayed values)
    ctx.strokeStyle = c.accent;
    ctx.lineWidth = 1.5 * Math.max(1, (window.devicePixelRatio||1)*0.6);
    ctx.beginPath();

    const {rawSamples, dtms} = data;
    const i0 = Math.max(0, Math.floor(xMin / dtms));
    const i1 = Math.min(rawSamples.length-1, Math.ceil(xMax / dtms));
    const nVis = i1 - i0 + 1;

    const pxCount = Math.max(1, Math.floor(pw));
    const spp = nVis / pxCount;

    for (let px=0; px<pxCount; px++){
      const a = Math.floor(i0 + px*spp);
      const b = Math.floor(i0 + (px+1)*spp);
      let mn =  1e9, mx = -1e9;
      const bb = Math.min(i1, Math.max(a+1, b));
      for (let i=a; i<=bb; i++){
        const v = rawSamples[i] * waveGain;
        if (v<mn) mn=v;
        if (v>mx) mx=v;
      }
      const x = padL + (px / (pxCount-1)) * pw;
      const y1p = mapY(mx);
      const y2p = mapY(mn);
      ctx.moveTo(x, y1p);
      ctx.lineTo(x, y2p);
    }
    ctx.stroke();

    // cursor highlight + bubble (Pause only)
    if (appState === State.PAUSED && cursorWave.active){
      const x = padL + (cursorWave.tms - xMin)/(xMax-xMin) * pw;
      const y = mapY(cursorWave.raw * waveGain);
      drawCursorPoint(ctx, c, x, y);

      bubbleWave.style.display = 'block';
      bubbleWave.textContent = `t=${cursorWave.tms.toFixed(3)} ms, amp=${(cursorWave.raw*waveGain).toFixed(4)}`;
      placeBubble(bubbleWave, wrapWave, x/cvWave.width, y/cvWave.height);
    } else {
      bubbleWave.style.display = 'none';
    }

    drawWaveAB(ctx, c, padL, padT, pw, ph, xMin, xMax, yMinDisp, yMaxDisp, innerPad);
  }

  // ----- Spectrum data -----
  function getSpectrumDisplayData(){
    const nyq = sampleRate/2;
    const minHz = clamp(parseFloat(minHzIn.value), 0, nyq);
    const maxHz = clamp(parseFloat(maxHzIn.value), minHz+1, nyq);

    const binCount = analyser ? analyser.frequencyBinCount : (snapSpec ? snapSpec.length : 0);
    if (!binCount) return null;

    const binHz = sampleRate / fftSize;
    let yArr = null;

    if (appState === State.RUNNING && analyser){
      if (yMode === 'db'){
        analyser.getFloatFrequencyData(freqBins);
        yArr = freqBins;
      } else {
        analyser.getByteFrequencyData(freqBinsByte);
        if (!getSpectrumDisplayData._tmp || getSpectrumDisplayData._tmp.length !== freqBinsByte.length){
          getSpectrumDisplayData._tmp = new Float32Array(freqBinsByte.length);
        }
        const tmp = getSpectrumDisplayData._tmp;
        for (let i=0;i<freqBinsByte.length;i++) tmp[i] = (freqBinsByte[i]/255)*100;
        yArr = tmp;
      }
    } else if (appState === State.PAUSED && snapSpec){
      yArr = snapSpec;
    } else {
      return null;
    }

    const x0 = specZoom.active ? specZoom.x0 : minHz;
    const x1 = specZoom.active ? specZoom.x1 : maxHz;

    let i0 = Math.floor(x0 / binHz);
    let i1 = Math.ceil(x1 / binHz);
    i0 = clamp(i0, 0, yArr.length-1);
    i1 = clamp(i1, 0, yArr.length-1);
    if (i1 < i0) [i0,i1] = [i1,i0];

    return {binHz, yArr, i0, i1, minHz, maxHz, x0, x1};
  }

  function drawSpecAB(ctx, c, padL, padT, pw, ph, xMin, xMax, yMin, yMax, innerPad){
    ctx.save();
    ctx.strokeStyle = c.accent2;
    ctx.lineWidth = 1.5 * Math.max(1, (window.devicePixelRatio||1)*0.6);

    const phIn = ph - 2*innerPad;
    const mapY = (val) => padT + innerPad + (1 - (val - yMin)/(yMax-yMin)) * phIn;

    function drawLine(pt){
      const x = padL + (pt.hz - xMin)/(xMax-xMin) * pw;
      ctx.beginPath();
      ctx.moveTo(x, padT);
      ctx.lineTo(x, padT+ph);
      ctx.stroke();

      const y = mapY(pt.val);
      ctx.fillStyle = c.accent2;
      ctx.beginPath();
      ctx.arc(x, y, 4.5 * Math.max(1, (window.devicePixelRatio||1)*0.6), 0, Math.PI*2);
      ctx.fill();
    }

    if (ABSpec.A) drawLine(ABSpec.A);
    if (ABSpec.B) drawLine(ABSpec.B);

    ctx.restore();
  }

  function drawSpec(c){
    const ctx = cvSpec.getContext('2d');
    const w = cvSpec.width, h = cvSpec.height;

    // Pause中は snapSpec を固定（クリック等で変化しない）
    if (appState === State.STOPPED){
      snapSpec = null;
    }

    const data = getSpectrumDisplayData();
    clearCanvas(ctx, w, h, c.bg);

    const padL = 70, padR = 18, padT = 58, padB = 36;
    const pw = w - padL - padR;
    const ph = h - padT - padB;

    ctx.strokeStyle = c.border;
    ctx.lineWidth = 1;
    ctx.strokeRect(padL, padT, pw, ph);

    ctx.strokeStyle = c.grid;
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let i=1;i<5;i++){
      const y = padT + ph * (i/5);
      ctx.moveTo(padL, y); ctx.lineTo(padL+pw, y);
    }
    ctx.stroke();

    if (!data){
      ctx.fillStyle = c.muted;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.font = `${Math.round(14*(window.devicePixelRatio||1))}px system-ui, sans-serif`;
      ctx.fillText('Startでマイク入力を開始します', padL+pw/2, padT+ph/2);
      return;
    }

    const {binHz, yArr, i0, i1, x0, x1} = data;

    let yMin, yMax;
    if (yMode === 'norm'){ yMin = 0; yMax = 100; }
    else { yMin = -140; yMax = 0; }

    const ticks = computeTicks(x0, x1, 5);

    // peak per tick segment
    specPeaks = [];
    for (let ti=0; ti<ticks.length; ti++){
      const tHz = ticks[ti];
      const next = (ti < ticks.length-1) ? ticks[ti+1] : x1;
      let a = clamp(Math.floor(tHz / binHz), i0, i1);
      let b = clamp(Math.floor(next / binHz), i0, i1);
      if (b < a) [a,b] = [b,a];
      let peak = -1e9;
      for (let i=a;i<=b;i++) peak = Math.max(peak, yArr[i]);
      if (!Number.isFinite(peak)) peak = 0;
      specPeaks.push(peak);
    }

    ctx.font = `${Math.round(12*(window.devicePixelRatio||1))}px system-ui, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillStyle = c.fg;
    ctx.strokeStyle = c.grid;
    ctx.lineWidth = 1;

    for (const tHz of ticks){
      const x = padL + (tHz - x0)/(x1-x0) * pw;
      ctx.beginPath();
      ctx.moveTo(x, padT); ctx.lineTo(x, padT+ph);
      ctx.stroke();
    }

    let lastX = -1e9;
    const minDx = 70 * Math.max(1, (window.devicePixelRatio||1));
    for (let ti=0; ti<ticks.length; ti++){
      const tHz = ticks[ti];
      const x = padL + (tHz - x0)/(x1-x0) * pw;
      if (x - lastX < minDx) continue;
      lastX = x;

      const lbl = formatHz(tHz);
      ctx.fillStyle = c.fg;
      ctx.textBaseline = 'bottom';
      ctx.fillText(lbl, x, padT - 26);

      const pk = specPeaks[ti];
      const pkTxt = (yMode==='norm') ? `${pk.toFixed(0)}%` : `${pk.toFixed(1)} dB`;
      ctx.fillStyle = c.muted;
      ctx.textBaseline = 'top';
      ctx.fillText(pkTxt, x, padT - 22);
    }

    ctx.textAlign = 'right';
    ctx.textBaseline = 'bottom';
    ctx.fillStyle = c.fg;
    ctx.fillText('Hz', padL+pw, padT - 26);

    // inner padding so 0% line doesn't stick to frame
    const innerPad = 2 * Math.max(1, (window.devicePixelRatio||1));
    const phIn = ph - 2*innerPad;
    const mapY = (val) => padT + innerPad + (1 - (val - yMin)/(yMax-yMin)) * phIn;

    ctx.strokeStyle = c.accent;
    ctx.lineWidth = 1.5 * Math.max(1, (window.devicePixelRatio||1)*0.6);
    ctx.beginPath();

    const nVis = i1 - i0 + 1;
    const pxCount = Math.max(1, Math.floor(pw));
    const spp = nVis / pxCount;

    for (let px=0; px<pxCount; px++){
      const a = Math.floor(i0 + px*spp);
      const b = Math.floor(i0 + (px+1)*spp);
      let mn =  1e9, mx = -1e9;
      const bb = Math.min(i1, Math.max(a+1, b));
      for (let i=a; i<=bb; i++){
        const v = yArr[i];
        if (v < mn) mn = v;
        if (v > mx) mx = v;
      }
      const x = padL + (px / (pxCount-1)) * pw;
      ctx.moveTo(x, mapY(mx));
      ctx.lineTo(x, mapY(mn));
    }
    ctx.stroke();

    if (appState === State.PAUSED && cursorSpec.active){
      const x = padL + (cursorSpec.hz - x0)/(x1-x0) * pw;
      const y = mapY(cursorSpec.val);
      drawCursorPoint(ctx, c, x, y);

      bubbleSpec.style.display = 'block';
      bubbleSpec.textContent = `f=${cursorSpec.hz.toFixed(1)} Hz, y=${(yMode==='norm'?cursorSpec.val.toFixed(2)+'%':cursorSpec.val.toFixed(2)+' dB')}`;
      placeBubble(bubbleSpec, wrapSpec, x/cvSpec.width, y/cvSpec.height);
    } else {
      bubbleSpec.style.display = 'none';
    }

    drawSpecAB(ctx, c, padL, padT, pw, ph, x0, x1, yMin, yMax, innerPad);
  }

  // ---------- Bubble placement ----------
  function placeBubble(bubble, wrap, nx, ny){
    const rect = wrap.getBoundingClientRect();
    bubble.style.left = `${nx * rect.width}px`;
    bubble.style.top  = `${ny * rect.height}px`;
  }

  // ---------- Overlay rectangle ----------
  function clearOverlay(which){
    const ov = (which==='wave') ? ovWave : ovSpec;
    const ctx = ov.getContext('2d');
    ctx.clearRect(0,0,ov.width, ov.height);
  }
  function drawOverlayRect(which, x0,y0,x1,y1){
    const ov = (which==='wave') ? ovWave : ovSpec;
    const ctx = ov.getContext('2d');
    const c = themeColors();
    ctx.clearRect(0,0,ov.width, ov.height);

    const left = Math.min(x0,x1), top = Math.min(y0,y1);
    const w = Math.abs(x1-x0), h = Math.abs(y1-y0);

    ctx.fillStyle = c.overlay;
    ctx.strokeStyle = c.overlayBorder;
    ctx.lineWidth = 2 * Math.max(1, (window.devicePixelRatio||1)*0.7);
    ctx.fillRect(left, top, w, h);
    ctx.strokeRect(left, top, w, h);
  }

  // ---------- Cursor + pick ----------
  function canvasPosFromEvent(ev, cv){
    const rect = cv.getBoundingClientRect();
    const x = (ev.clientX - rect.left) * (cv.width / rect.width);
    const y = (ev.clientY - rect.top)  * (cv.height / rect.height);
    return {x,y};
  }

  function pickWaveAtCanvas(px, py){
    if (!snapWave) return null;
    const w = cvWave.width, h = cvWave.height;
    const padL = 64, padR = 18, padT = 42, padB = 36;
    const pw = w - padL - padR;
    const ph = h - padT - padB;
    if (px < padL || px > padL+pw || py < padT || py > padT+ph) return null;

    const xMin = (waveZoom.active ? waveZoom.x0 : 0) * 1000;
    const xMax = (waveZoom.active ? waveZoom.x1 : waveWindowSec) * 1000;
    const tms = xMin + ((px - padL)/pw) * (xMax - xMin);

    const dtms = 1000 / sampleRate;
    const idx = clamp(Math.round(tms / dtms), 0, snapWave.length-1);
    const raw = snapWave[idx];
    return {tms, raw};
  }

  function pickSpecAtCanvas(px, py){
    const data = getSpectrumDisplayData();
    if (!data) return null;
    const {binHz, yArr, x0, x1, i0, i1} = data;

    const w = cvSpec.width, h = cvSpec.height;
    const padL = 70, padR = 18, padT = 58, padB = 36;
    const pw = w - padL - padR;
    const ph = h - padT - padB;
    if (px < padL || px > padL+pw || py < padT || py > padT+ph) return null;

    const hz = x0 + ((px - padL)/pw) * (x1 - x0);
    const idx = clamp(Math.round(hz / binHz), i0, i1);
    const val = yArr[idx];
    return {hz: idx*binHz, val};
  }

  function updateDeltas(){
    if (ABWave.A && ABWave.B){
      const dt = ABWave.B.tms - ABWave.A.tms;
      const da = (ABWave.B.raw - ABWave.A.raw) * waveGain;
      deltaWave.textContent = `Δ: Δt=${dt.toFixed(3)} ms, Δamp=${da.toFixed(4)}`;
    } else {
      deltaWave.textContent = 'Δ: —';
    }

    if (ABSpec.A && ABSpec.B){
      const df = ABSpec.B.hz - ABSpec.A.hz;
      const dy = ABSpec.B.val - ABSpec.A.val;
      const unit = (yMode==='norm') ? '%' : 'dB';
      deltaSpec.textContent = `Δ: Δf=${df.toFixed(1)} Hz, Δy=${dy.toFixed(2)} ${unit}`;
    } else {
      deltaSpec.textContent = 'Δ: —';
    }
  }

  function cycleAB(which, pt){
    if (which==='wave'){
      if (!ABWave.A || (ABWave.A && ABWave.B)){
        ABWave.A = {tms: pt.tms, raw: pt.raw};
        ABWave.B = null;
      } else if (ABWave.A && !ABWave.B){
        ABWave.B = {tms: pt.tms, raw: pt.raw};
      }
    } else {
      if (!ABSpec.A || (ABSpec.A && ABSpec.B)){
        ABSpec.A = {hz: pt.hz, val: pt.val};
        ABSpec.B = null;
      } else if (ABSpec.A && !ABSpec.B){
        ABSpec.B = {hz: pt.hz, val: pt.val};
      }
    }
    updateDeltas();
  }

  // ---------- Apply zoom / pan ----------
  function applyZoomFromRect(target, x0,y0,x1,y1){
    if (Math.abs(x1-x0) < 8 || Math.abs(y1-y0) < 8) return;

    if (target==='wave'){
      const w = cvWave.width, h = cvWave.height;
      const padL = 64, padR = 18, padT = 42, padB = 36;
      const pw = w - padL - padR;
      const ph = h - padT - padB;

      const left = clamp(Math.min(x0,x1), padL, padL+pw);
      const right = clamp(Math.max(x0,x1), padL, padL+pw);
      const top = clamp(Math.min(y0,y1), padT, padT+ph);
      const bottom = clamp(Math.max(y0,y1), padT, padT+ph);

      const xMinMs = (waveZoom.active ? waveZoom.x0 : 0) * 1000;
      const xMaxMs = (waveZoom.active ? waveZoom.x1 : waveWindowSec) * 1000;

      // Y zoom is in displayed space; convert back to RAW by dividing by gain
      let yMinDisp = -1 * waveGain, yMaxDisp = 1 * waveGain;
      if (waveZoom.active){
        const r0 = Math.min(waveZoom.y0,waveZoom.y1);
        const r1 = Math.max(waveZoom.y0,waveZoom.y1);
        yMinDisp = r0 * waveGain;
        yMaxDisp = r1 * waveGain;
      }

      const nx0 = (left - padL)/pw;
      const nx1 = (right - padL)/pw;
      const ny0 = (top - padT)/ph;
      const ny1 = (bottom - padT)/ph;

      const newX0ms = lerp(xMinMs, xMaxMs, nx0);
      const newX1ms = lerp(xMinMs, xMaxMs, nx1);

      const newYMaxDisp = lerp(yMaxDisp, yMinDisp, ny0);
      const newYMinDisp = lerp(yMaxDisp, yMinDisp, ny1);

      waveZoom.active = true;
      waveZoom.x0 = clamp(newX0ms/1000, 0, waveWindowSec);
      waveZoom.x1 = clamp(newX1ms/1000, 0, waveWindowSec);

      waveZoom.y0 = newYMinDisp / waveGain; // store raw
      waveZoom.y1 = newYMaxDisp / waveGain;
    } else {
      const w = cvSpec.width, h = cvSpec.height;
      const padL = 70, padR = 18, padT = 58, padB = 36;
      const pw = w - padL - padR;

      const left = clamp(Math.min(x0,x1), padL, padL+pw);
      const right = clamp(Math.max(x0,x1), padL, padL+pw);

      const baseMin = specZoom.active ? specZoom.x0 : parseFloat(minHzIn.value);
      const baseMax = specZoom.active ? specZoom.x1 : parseFloat(maxHzIn.value);

      const nx0 = (left - padL)/pw;
      const nx1 = (right - padL)/pw;

      const newX0 = lerp(baseMin, baseMax, nx0);
      const newX1 = lerp(baseMin, baseMax, nx1);

      specZoom.active = true;
      specZoom.x0 = Math.min(newX0, newX1);
      specZoom.x1 = Math.max(newX0, newX1);
    }
  }

  function applyPanFromDrag(target, x0,y0,x1,y1){
    const dx = x1 - x0;
    const dy = y1 - y0;

    if (target==='wave'){
      const w = cvWave.width, h = cvWave.height;
      const padL = 64, padR = 18, padT = 42, padB = 36;
      const pw = w - padL - padR;
      const ph = h - padT - padB;

      const xMinMs = (waveZoom.active ? waveZoom.x0 : 0) * 1000;
      const xMaxMs = (waveZoom.active ? waveZoom.x1 : waveWindowSec) * 1000;
      const spanX = xMaxMs - xMinMs;

      // pan in displayed y space, then convert back to raw
      let yMinRaw = -1, yMaxRaw = 1;
      if (waveZoom.active){
        yMinRaw = Math.min(waveZoom.y0,waveZoom.y1);
        yMaxRaw = Math.max(waveZoom.y0,waveZoom.y1);
      }
      const yMinDisp = yMinRaw * waveGain;
      const yMaxDisp = yMaxRaw * waveGain;
      const spanYDisp = yMaxDisp - yMinDisp;

      const dXms = -(dx/pw) * spanX;
      const dYDisp = (dy/ph) * spanYDisp;

      let nx0 = xMinMs + dXms;
      let nx1 = xMaxMs + dXms;

      const minAll = 0;
      const maxAll = waveWindowSec*1000;
      const shift = clamp(nx0, minAll, maxAll-spanX) - nx0;
      nx0 += shift; nx1 += shift;

      let nyMinDisp = yMinDisp + dYDisp;
      let nyMaxDisp = yMaxDisp + dYDisp;

      waveZoom.active = true;
      waveZoom.x0 = nx0/1000;
      waveZoom.x1 = nx1/1000;
      waveZoom.y0 = nyMinDisp / waveGain;
      waveZoom.y1 = nyMaxDisp / waveGain;
    } else {
      const w = cvSpec.width, h = cvSpec.height;
      const padL = 70, padR = 18, padT = 58, padB = 36;
      const pw = w - padL - padR;

      const baseMin = specZoom.active ? specZoom.x0 : parseFloat(minHzIn.value);
      const baseMax = specZoom.active ? specZoom.x1 : parseFloat(maxHzIn.value);
      const span = baseMax - baseMin;

      const dHz = -(dx/pw) * span;

      let nx0 = baseMin + dHz;
      let nx1 = baseMax + dHz;

      const minAll = parseFloat(minHzIn.value);
      const maxAll = parseFloat(maxHzIn.value);
      const shift = clamp(nx0, minAll, maxAll-span) - nx0;
      nx0 += shift; nx1 += shift;

      specZoom.active = true;
      specZoom.x0 = nx0;
      specZoom.x1 = nx1;
    }
  }

  // ---------- Pointer events (統一：ここだけで操作) ----------
  function handlePointerMove(target, ev){
    if (ev.pointerType !== 'mouse' && ev.pointerType !== 'pen' && ev.pointerType !== 'touch') return;

    // dragging overlay
    if (drag.active && drag.target === target && drag.ptrId === ev.pointerId){
      const p = (target==='wave') ? canvasPosFromEvent(ev, cvWave) : canvasPosFromEvent(ev, cvSpec);
      drag.x1 = p.x; drag.y1 = p.y;
      if (drag.kind === 'zoom'){
        drawOverlayRect(target, drag.x0, drag.y0, drag.x1, drag.y1);
      }
      return;
    }

    // cursor info only in PAUSED
    if (appState !== State.PAUSED) return;

    const p = (target==='wave') ? canvasPosFromEvent(ev, cvWave) : canvasPosFromEvent(ev, cvSpec);
    if (target==='wave'){
      const pt = pickWaveAtCanvas(p.x, p.y);
      if (!pt){ cursorWave.active=false; bubbleWave.style.display='none'; drawOnce(); return; }
      cursorWave.active = true;
      cursorWave.tms = pt.tms;
      cursorWave.raw = pt.raw;
      drawOnce();
    } else {
      const pt = pickSpecAtCanvas(p.x, p.y);
      if (!pt){ cursorSpec.active=false; bubbleSpec.style.display='none'; drawOnce(); return; }
      cursorSpec.active = true;
      cursorSpec.hz = pt.hz;
      cursorSpec.val = pt.val;
      drawOnce();
    }
  }

  function handlePointerDown(target, ev){
    // prevent scroll / text selection etc.
    ev.preventDefault();

    // Always allow dbl-click zoom reset (mouse)
    // (actual dblclick handler below too)

    // track pointers (for pinch gestures)
    pointers.set(ev.pointerId, {x: ev.clientX, y: ev.clientY});

    // 2点選択：PICK中は「クリック（押下）でA/B」だけ。ドラッグは開始しない。
    if (appState === State.PAUSED && mode === Mode.PICK){
      const p = (target==='wave') ? canvasPosFromEvent(ev, cvWave) : canvasPosFromEvent(ev, cvSpec);
      const pt = (target==='wave') ? pickWaveAtCanvas(p.x,p.y) : pickSpecAtCanvas(p.x,p.y);
      if (!pt) return;
      cycleAB(target, pt);
      drawOnce();
      return;
    }

    // ZOOMモード：Pause中のみドラッグ操作を開始（Shiftでパン）
    if (appState === State.PAUSED && mode === Mode.ZOOM){
      drag.active = true;
      drag.kind = ev.shiftKey ? 'pan' : 'zoom';
      drag.target = target;
      drag.ptrId = ev.pointerId;
      drag.shift = !!ev.shiftKey;
      const p = (target==='wave') ? canvasPosFromEvent(ev, cvWave) : canvasPosFromEvent(ev, cvSpec);
      drag.x0 = drag.x1 = p.x;
      drag.y0 = drag.y1 = p.y;
      if (drag.kind === 'zoom'){
        drawOverlayRect(target, drag.x0, drag.y0, drag.x1, drag.y1);
      } else {
        clearOverlay(target);
      }
      (target==='wave' ? wrapWave : wrapSpec).setPointerCapture(ev.pointerId);
      return;
    }

    // Running / Stopped: no drag, but keep pointers for pinch bookkeeping
  }

  function handlePointerUp(target, ev){
    pointers.delete(ev.pointerId);

    // Finish drag
    if (drag.active && drag.target === target && drag.ptrId === ev.pointerId){
      const p = (target==='wave') ? canvasPosFromEvent(ev, cvWave) : canvasPosFromEvent(ev, cvSpec);
      drag.x1 = p.x; drag.y1 = p.y;

      if (drag.kind === 'zoom') applyZoomFromRect(target, drag.x0, drag.y0, drag.x1, drag.y1);
      else applyPanFromDrag(target, drag.x0, drag.y0, drag.x1, drag.y1);

      drag.active = false;
      drag.ptrId = null;
      clearOverlay(target);
      drawOnce();
      return;
    }

    // Pinch gesture end
    if (pointers.size < 2) gesture = null;
  }

  // pinch start when two pointers down
  function maybeStartGesture(target){
    if (appState !== State.PAUSED) return;
    if (mode !== Mode.ZOOM) return;
    if (pointers.size !== 2) return;

    const pts = [...pointers.values()];
    const dx = pts[1].x - pts[0].x;
    const dy = pts[1].y - pts[0].y;
    const dist = Math.hypot(dx, dy);
    const cx = (pts[0].x + pts[1].x) / 2;
    const cy = (pts[0].y + pts[1].y) / 2;

    gesture = {
      target,
      startDist: dist,
      startCenter: {x: cx, y: cy},
      startWaveZoom: {...waveZoom},
      startSpecZoom: {...specZoom},
    };
  }

  function handlePointerMoveForGesture(target, ev){
    if (!gesture || gesture.target !== target) return;
    if (pointers.size !== 2) return;
    if (appState !== State.PAUSED) return;
    if (mode !== Mode.ZOOM) return;

    const wrap = (target==='wave') ? wrapWave : wrapSpec;

    const pts = [...pointers.values()];
    const dx = pts[1].x - pts[0].x;
    const dy = pts[1].y - pts[0].y;
    const dist = Math.hypot(dx, dy);
    const cx = (pts[0].x + pts[1].x) / 2;
    const cy = (pts[0].y + pts[1].y) / 2;

    const scale = dist / Math.max(1e-6, gesture.startDist);
    const panX = cx - gesture.startCenter.x;
    const panY = cy - gesture.startCenter.y;

    if (target === 'wave'){
      const z0 = gesture.startWaveZoom;
      const baseX0 = z0.active ? z0.x0 : 0;
      const baseX1 = z0.active ? z0.x1 : waveWindowSec;

      // y zoom uses RAW window; pinch zoom affects RAW y-range (display will apply gain)
      const baseY0 = z0.active ? Math.min(z0.y0,z0.y1) : -1;
      const baseY1 = z0.active ? Math.max(z0.y0,z0.y1) :  1;

      const spanX = (baseX1 - baseX0) / scale;
      const spanY = (baseY1 - baseY0) / scale;

      const rect = wrap.getBoundingClientRect();
      const nx = (cx - rect.left) / rect.width;
      const ny = (cy - rect.top)  / rect.height;

      const centerX = lerp(baseX0, baseX1, clamp(nx,0,1));
      const centerY = lerp(baseY1, baseY0, clamp(ny,0,1));

      let nx0 = centerX - spanX/2;
      let nx1 = centerX + spanX/2;

      const dxs = -(panX / rect.width) * (baseX1 - baseX0);
      const dys =  (panY / rect.height) * (baseY1 - baseY0);

      nx0 += dxs; nx1 += dxs;

      const minAll = 0, maxAll = waveWindowSec;
      const span = nx1 - nx0;
      const shift = clamp(nx0, minAll, maxAll-span) - nx0;
      nx0 += shift; nx1 += shift;

      const ny0 = (centerY - spanY/2) + dys;
      const ny1 = (centerY + spanY/2) + dys;

      waveZoom.active = true;
      waveZoom.x0 = clamp(nx0, 0, waveWindowSec);
      waveZoom.x1 = clamp(nx1, 0, waveWindowSec);
      waveZoom.y0 = ny0;
      waveZoom.y1 = ny1;

      drawOnce();
    } else {
      const z0 = gesture.startSpecZoom;
      const baseX0 = z0.active ? z0.x0 : parseFloat(minHzIn.value);
      const baseX1 = z0.active ? z0.x1 : parseFloat(maxHzIn.value);
      const rect = wrap.getBoundingClientRect();
      const nx = (cx - rect.left) / rect.width;
      const centerX = lerp(baseX0, baseX1, clamp(nx,0,1));
      const spanX = (baseX1 - baseX0) / scale;

      let nx0 = centerX - spanX/2;
      let nx1 = centerX + spanX/2;

      const dHz = -(panX / rect.width) * (baseX1 - baseX0);
      nx0 += dHz; nx1 += dHz;

      const minAll = parseFloat(minHzIn.value);
      const maxAll = parseFloat(maxHzIn.value);
      const span = nx1 - nx0;
      const shift = clamp(nx0, minAll, maxAll-span) - nx0;
      nx0 += shift; nx1 += shift;

      specZoom.active = true;
      specZoom.x0 = nx0;
      specZoom.x1 = nx1;

      drawOnce();
    }
  }

  // bind pointer events
  wrapWave.addEventListener('pointerdown', (e) => { handlePointerDown('wave', e); maybeStartGesture('wave'); });
  wrapWave.addEventListener('pointermove', (e) => {
    if (pointers.has(e.pointerId)) pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
    handlePointerMoveForGesture('wave', e);
    handlePointerMove('wave', e);
  });
  wrapWave.addEventListener('pointerup',   (e) => handlePointerUp('wave', e));
  wrapWave.addEventListener('pointercancel',(e) => handlePointerUp('wave', e));

  wrapSpec.addEventListener('pointerdown', (e) => { handlePointerDown('spec', e); maybeStartGesture('spec'); });
  wrapSpec.addEventListener('pointermove', (e) => {
    if (pointers.has(e.pointerId)) pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
    handlePointerMoveForGesture('spec', e);
    handlePointerMove('spec', e);
  });
  wrapSpec.addEventListener('pointerup',   (e) => handlePointerUp('spec', e));
  wrapSpec.addEventListener('pointercancel',(e) => handlePointerUp('spec', e));

  // Double click zoom reset (ALWAYS allowed)
  wrapWave.addEventListener('dblclick', (e) => { resetWaveZoom(); clearOverlay('wave'); drawOnce(); });
  wrapSpec.addEventListener('dblclick', (e) => { resetSpecZoom(); clearOverlay('spec'); drawOnce(); });

  // prevent wheel zoom
  wrapWave.addEventListener('wheel', (e) => { e.preventDefault(); }, {passive:false});
  wrapSpec.addEventListener('wheel', (e) => { e.preventDefault(); }, {passive:false});

  // ---------- Initialize defaults ----------
  function initUI(){
    setTheme('light');
    setView('both');
    setMode(Mode.ZOOM);
    setWaveWindow(1.0);
    setWaveGain(1.0);
    setSpecRange(200, 1500);
    setFFTSize(8192);
    // setYAxisMode triggers snapshot; do direct:
    yMode = 'norm';
    btnSpecYAxis.textContent = '縦軸：規格化';
    setAppState(State.STOPPED);
    resizeCanvases();
    drawOnce();
    updateDeltas();
  }

  initUI();
})();
</script>
</body>
</html>
