<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mic Waveform + Acoustic Spectrum</title>
  <style>
    :root{
      --bg:#ffffff;
      --fg:#111111;
      --panel:#fafafa;
      --border:#d9d9d9;
      --grid:#e9e9e9;
      --muted:#666666;
      --accent:#ff6a00;
      --peak:#1a7f37;
      --abA:#0b57d0;
      --abB:#b3261e;
      --shadow: rgba(0,0,0,0.06);
    }
    [data-theme="dark"]{
      --bg:#0c0f14;
      --fg:#e9eef6;
      --panel:#121826;
      --border:#283043;
      --grid:#1e2636;
      --muted:#a6b2c3;
      --accent:#ff9a3c;
      --peak:#58d68d;
      --abA:#8ab4f8;
      --abB:#ff8a80;
      --shadow: rgba(0,0,0,0.35);
    }

    *{ box-sizing:border-box; }
    body{
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      margin: 12px;
      background: var(--bg);
      color: var(--fg);
    }
    h2{ margin: 0 0 10px 0; font-size: 18px; }

    .panel{
      max-width: 1100px;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--panel);
      box-shadow: 0 4px 12px var(--shadow);
      display:flex;
      flex-direction: column;
      gap:10px;
    }

    .inline{
      display:flex;
      gap:10px;
      flex-wrap: wrap;
      align-items:center;
    }

    button{
      padding: 10px 14px;
      font-size: 15px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--fg);
      border-radius: 10px;
      cursor: pointer;
    }
    button.primary{
      border-color: transparent;
      background: var(--fg);
      color: var(--bg);
    }
    [data-theme="dark"] button.primary{
      background: #e9eef6;
      color: #0c0f14;
    }
    button.danger{
      border-color: transparent;
      background: #b3261e;
      color: #fff;
    }
    [data-theme="dark"] button.danger{
      background: #ff8a80;
      color: #0c0f14;
    }
    button:disabled{
      opacity: 0.5;
      cursor: not-allowed;
    }

    label{ font-size: 14px; color: var(--fg); }
    select, input[type="number"]{
      font-size: 14px;
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--fg);
      outline: none;
    }
    input[type="range"]{ width: 260px; }

    .tabs{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .tab{
      padding: 8px 10px;
      border: 1px solid var(--border);
      background: transparent;
      border-radius: 999px;
      cursor:pointer;
      font-size: 14px;
      color: var(--fg);
    }
    .tab.active{
      background: var(--fg);
      color: var(--bg);
      border-color: transparent;
    }
    [data-theme="dark"] .tab.active{
      background:#e9eef6;
      color:#0c0f14;
    }

    .row{
      display:flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: stretch;
      max-width: 1100px;
      margin-top: 12px;
    }
    .card{
      flex: 1 1 520px;
      min-width: 300px;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--panel);
      box-shadow: 0 4px 12px var(--shadow);
      display:flex;
      flex-direction: column;
      gap: 8px;
    }
    .cardTitle{
      font-size: 14px;
      color: var(--muted);
      display:flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
    }
    .canvasWrap{
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
      background: var(--bg);
    }
    canvas{
      width: 100%;
      height: 240px;
      display:block;
      touch-action: none;
    }

    .delta{
      border-top: 1px dashed var(--border);
      padding-top: 8px;
      font-size: 18px;
      line-height: 1.35;
      font-weight: 650;
      color: var(--fg);
      min-height: 2.2em;
      white-space: pre-wrap;
    }
    .delta small{
      font-size: 13px;
      font-weight: 500;
      color: var(--muted);
    }

    .status{
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--bg);
      font-size: 13px;
      line-height: 1.45;
      white-space: pre-wrap;
    }

    .pill{
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      font-size: 12px;
      color: var(--muted);
    }

    .hint{
      font-size: 12px;
      color: var(--muted);
    }

    .hidden{ display:none !important; }

    @media (max-width: 520px){
      input[type="range"]{ width: 200px; }
      canvas{ height: 220px; }
      .delta{ font-size: 16px; }
    }
  </style>
</head>

<body>
  <h2>マイク入力：波形（直近N秒）＋ 音響スペクトル（正規化・ズーム・2点選択・CSV）</h2>

  <div class="panel">
    <div class="inline">
      <button id="btnStart" class="primary">Start</button>
      <button id="btnPause" disabled>Pause</button>
      <button id="btnReset" class="danger" disabled>Reset</button>

      <span class="pill" id="srPill">sampleRate: -</span>
      <span style="flex:1 1 auto;"></span>
      <button id="btnTheme">白黒反転</button>
    </div>

    <div class="inline">
      <div class="tabs" role="tablist" aria-label="表示切替">
        <button class="tab active" id="tabBoth">同時表示</button>
        <button class="tab" id="tabWave">波形のみ</button>
        <button class="tab" id="tabSpec">音響スペクトルのみ</button>
      </div>

      <span class="pill" id="modePill">モード: ズーム</span>
      <button id="btnMode">ズーム / 2点選択 切替</button>
      <button id="btnZoomReset" disabled>ズームリセット</button>
    </div>

    <div class="inline">
      <label>
        波形時間窓（N秒）:
        <input id="secRange" type="range" min="0.05" max="5" step="0.01" value="1.00">
      </label>
      <label>
        <input id="secNum" type="number" min="0.05" max="5" step="0.01" value="1.00" style="width:90px;">
      </label>

      <label>
        FFTサイズ:
        <select id="fft"></select>
      </label>
    </div>

    <div class="inline">
      <label>スペクトル周波数　最小:
        <select id="fminPreset"></select>
      </label>
      <input id="fminCustom" type="number" step="1" value="200" style="width:92px;" class="hidden">

      <label>最大:
        <select id="fmaxPreset"></select>
      </label>
      <input id="fmaxCustom" type="number" step="1" value="1500" style="width:92px;" class="hidden">

      <span class="hint">（デフォルト: 200〜1500 Hz / 縦軸: 正規化 0〜100%）</span>

      <span style="flex:1 1 auto;"></span>

      <button id="btnResetABWave" disabled>波形 A/B リセット</button>
      <button id="btnResetABSpec" disabled>スペクトル A/B リセット</button>
      <button id="btnCSV" disabled>CSV DL</button>
    </div>

    <div class="status" id="status">状態: 停止中</div>
  </div>

  <div class="row" id="row">
    <div class="card" id="cardWave">
      <div class="cardTitle">
        <span>① 波形</span>
        <span class="pill">ms 目盛：上段</span>
      </div>
      <div class="canvasWrap">
        <canvas id="wave"></canvas>
      </div>
      <div class="delta" id="deltaWave">
        <small>Δ（波形）：Pause中にA/Bを選択すると表示されます</small>
      </div>
    </div>

    <div class="card" id="cardSpec">
      <div class="cardTitle">
        <span>② 音響スペクトル</span>
        <span class="pill">Hz 目盛：上段 / PEAK：目盛の下</span>
      </div>
      <div class="canvasWrap">
        <canvas id="spec"></canvas>
      </div>
      <div class="delta" id="deltaSpec">
        <small>Δ（音響スペクトル）：Pause中にA/Bを選択すると表示されます</small>
      </div>
    </div>
  </div>

<script>
(() => {
  // ========= DOM =========
  const btnStart = document.getElementById('btnStart');
  const btnPause = document.getElementById('btnPause');
  const btnReset = document.getElementById('btnReset');
  const btnTheme = document.getElementById('btnTheme');

  const tabBoth = document.getElementById('tabBoth');
  const tabWave = document.getElementById('tabWave');
  const tabSpec = document.getElementById('tabSpec');

  const btnMode = document.getElementById('btnMode');
  const modePill = document.getElementById('modePill');
  const btnZoomReset = document.getElementById('btnZoomReset');

  const secRange = document.getElementById('secRange');
  const secNum   = document.getElementById('secNum');
  const fftS = document.getElementById('fft');

  const fminPreset = document.getElementById('fminPreset');
  const fmaxPreset = document.getElementById('fmaxPreset');
  const fminCustom = document.getElementById('fminCustom');
  const fmaxCustom = document.getElementById('fmaxCustom');

  const btnResetABWave = document.getElementById('btnResetABWave');
  const btnResetABSpec = document.getElementById('btnResetABSpec');
  const btnCSV = document.getElementById('btnCSV');

  const srPill = document.getElementById('srPill');
  const status = document.getElementById('status');

  const deltaWave = document.getElementById('deltaWave');
  const deltaSpec = document.getElementById('deltaSpec');

  const cardWave = document.getElementById('cardWave');
  const cardSpec = document.getElementById('cardSpec');

  const waveC = document.getElementById('wave');
  const specC = document.getElementById('spec');
  const wctx = waveC.getContext('2d');
  const sctx = specC.getContext('2d');

  // ========= Audio =========
  let audioCtx = null, analyser = null, src = null, stream = null;
  let rafId = null;

  let isRunning = false;  // audio active
  let isPaused = false;   // drawing paused

  // ========= Config =========
  const FFT_LIST = [1024, 2048, 4096, 8192, 16384, 32768];
  FFT_LIST.forEach(n => {
    const opt = document.createElement('option');
    opt.value = String(n);
    opt.textContent = String(n);
    if (n === 8192) opt.selected = true; // default
    fftS.appendChild(opt);
  });

  const FMIN_LIST = [0, 20, 100, 200, 300, 400, 500, 1000, '任意'];
  const FMAX_LIST = [1000, 1500, 2000, 5000, 10000, 20000, '任意']; // +1.5k

  function fillSelect(sel, list, defaultValue){
    sel.innerHTML = '';
    for (const v of list){
      const opt = document.createElement('option');
      opt.value = String(v);
      opt.textContent = (typeof v === 'number') ? (v >= 1000 ? `${v/1000}k` : `${v}`) : String(v);
      sel.appendChild(opt);
    }
    sel.value = String(defaultValue);
  }
  fillSelect(fminPreset, FMIN_LIST, 200);
  fillSelect(fmaxPreset, FMAX_LIST, 1500);

  // ========= Theme =========
  function setTheme(dark){ document.documentElement.dataset.theme = dark ? 'dark' : 'light'; }
  setTheme(false);

  // ========= View =========
  let view = 'both'; // both | wave | spec
  function setActiveTab(which){
    view = which;
    tabBoth.classList.toggle('active', which === 'both');
    tabWave.classList.toggle('active', which === 'wave');
    tabSpec.classList.toggle('active', which === 'spec');
    cardWave.classList.toggle('hidden', which === 'spec');
    cardSpec.classList.toggle('hidden', which === 'wave');
    resizeAll();
    redrawAll();
  }

  function resizeCanvasToCSS(canvas){
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width  = Math.max(1, Math.round(rect.width * dpr));
    canvas.height = Math.max(1, Math.round(rect.height * dpr));
  }
  function resizeAll(){
    const hBoth = 240, hSingle = 360;
    if (view === 'both'){
      waveC.style.height = hBoth + 'px';
      specC.style.height = hBoth + 'px';
    } else if (view === 'wave'){
      waveC.style.height = hSingle + 'px';
    } else {
      specC.style.height = hSingle + 'px';
    }
    resizeCanvasToCSS(waveC);
    resizeCanvasToCSS(specC);
  }
  window.addEventListener('resize', () => { resizeAll(); redrawAll(); });

  // ========= Data =========
  let ring = null;
  let ringWrite = 0;

  let snapWave = null;
  let snapSR = 0;
  let snapFFT = 0;

  let snapFreqDb = null;
  let snapFreqHz = null;

  let cursorWave = null;
  let cursorSpec = null;
  let peak = null;

  // ========= Spectrum range / zoom =========
  let fminHz = 200;
  let fmaxHz = 1500;

  let waveZoom = {t0:0, t1:1};
  let specZoom = {f0:200, f1:1500};

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  // ========= Mode =========
  let mode = 'zoom'; // 'zoom' | 'ab'
  let waveAB = {A:null, B:null};
  let specAB = {A:null, B:null};

  function setMode(m){
    mode = m;
    modePill.textContent = `モード: ${m === 'zoom' ? 'ズーム' : '2点選択'}`;
    redrawAll();
  }
  setMode('zoom');

  // ========= UI state helpers =========
  function applyButtonStates(){
    // Start: only when stopped
    btnStart.disabled = isRunning;
    // Pause: only when running
    btnPause.disabled = !isRunning;
    btnPause.textContent = isPaused ? 'Resume' : 'Pause';
    // Reset: only when running or paused (same meaning)
    btnReset.disabled = !isRunning;

    // Pause-only tools
    const pauseOnly = isPaused && isRunning;
    btnZoomReset.disabled = !pauseOnly;
    btnCSV.disabled = !pauseOnly;
    btnResetABWave.disabled = !pauseOnly;
    btnResetABSpec.disabled = !pauseOnly;
  }

  function setStatus(){
    const st = (!isRunning) ? '停止中' : (isPaused ? '一時停止中' : '計測中');
    const peakText = peak ? `${peak.fHz.toFixed(1)} Hz  (${peak.norm.toFixed(1)}%)` : '-';
    const cw = cursorWave ? `t=${(cursorWave.tSec*1000).toFixed(2)} ms, amp=${cursorWave.amp.toFixed(4)}` : '-';
    const cs = cursorSpec ? `f=${cursorSpec.fHz.toFixed(1)} Hz, ${cursorSpec.norm.toFixed(2)}%, ${cursorSpec.db.toFixed(1)} dB` : '-';

    status.textContent =
`状態: ${st}
ピーク: ${peakText}
カーソル（波形）: ${cw}
カーソル（スペクトル）: ${cs}
ショートカット:
S=Start, P=Pause/Resume, R=Reset, Z=ズーム/2点選択, W=波形, F=スペクトル, B=同時表示, V=CSV(停止中のみ), Esc=解除
メモ:
・Pause中のみ、ズーム・2点選択・CSV DL・A/Bが使えます
・ズームモード（Pause中）:
  PC: ドラッグ=拡大 / Shift+ドラッグ=移動 / ダブルクリック=リセット
  スマホ: ピンチ=拡大縮小 / 2本指ドラッグ=移動
・2点選択モード（Pause中）: A→Bの順にタップ（Δは各グラフ下）`;
  }

  // ========= ticks/grid =========
  function tickCountForWidth(px){ return (px < 520) ? 3 : 5; }

  function drawTopTicks(ctx, W, H, labels){
    ctx.save();
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--muted').trim();
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid').trim();
    ctx.lineWidth = 1;

    const topH = Math.min(30, Math.max(22, Math.round(H*0.12)));
    ctx.beginPath();
    ctx.moveTo(0, topH);
    ctx.lineTo(W, topH);
    ctx.stroke();

    ctx.font = `${Math.max(12, Math.round(topH*0.45))}px system-ui`;
    ctx.textBaseline = 'middle';

    for (const l of labels){
      ctx.beginPath();
      ctx.moveTo(l.x, topH);
      ctx.lineTo(l.x, topH + 6);
      ctx.stroke();

      const tw = ctx.measureText(l.text).width;
      const x = clamp(l.x - tw/2, 2, W - tw - 2);
      ctx.fillText(l.text, x, Math.round(topH*0.55));
    }
    ctx.restore();
    return topH;
  }

  function clearAndGrid(ctx, W, H, topStripH){
    const bg = getComputedStyle(document.documentElement).getPropertyValue('--bg').trim();
    const grid = getComputedStyle(document.documentElement).getPropertyValue('--grid').trim();
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = bg;
    ctx.fillRect(0,0,W,H);

    ctx.save();
    ctx.strokeStyle = grid;
    ctx.lineWidth = 1;

    const innerTop = topStripH;
    const innerH = H - innerTop;

    for (let i=1; i<4; i++){
      const y = innerTop + (innerH*i)/4;
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
    }
    for (let i=1; i<10; i++){
      const x = (W*i)/10;
      ctx.beginPath(); ctx.moveTo(x,innerTop); ctx.lineTo(x,H); ctx.stroke();
    }
    ctx.restore();
  }

  // ========= waveform =========
  function timeWinSec(){
    const v = parseFloat(secNum.value || "1");
    return clamp(v, 0.05, 5);
  }
  function allocRing(){
    if (!audioCtx) return;
    const sr = audioCtx.sampleRate;
    const n = Math.max(1, Math.floor(sr * timeWinSec()));
    ring = new Float32Array(n);
    ringWrite = 0;
    waveZoom = {t0:0, t1: timeWinSec()};
  }

  function waveValueAt(canvasX){
    if (!ring || !audioCtx) return null;
    const W = waveC.width;
    const win = timeWinSec();
    const frac = clamp(canvasX / W, 0, 1);
    const t = waveZoom.t0 + frac * (waveZoom.t1 - waveZoom.t0);

    const idxInWindow = Math.round((t / win) * (ring.length - 1));
    const idxRing = (ringWrite + idxInWindow) % ring.length;
    return { tSec: t, amp: ring[idxRing] };
  }
  function waveXFromTime(tSec){
    const W = waveC.width;
    const frac = (tSec - waveZoom.t0) / (waveZoom.t1 - waveZoom.t0);
    return clamp(frac, 0, 1) * W;
  }

  function drawWave(){
    const W = waveC.width, H = waveC.height;
    const nTicks = tickCountForWidth(W / (window.devicePixelRatio || 1));

    const t0 = waveZoom.t0, t1 = waveZoom.t1;
    const labels = [];
    for (let i=0; i<nTicks; i++){
      const frac = (nTicks === 1) ? 0 : (i/(nTicks-1));
      const t = t0 + frac*(t1-t0);
      labels.push({ x: frac*W, text: `${Math.round(t*1000)} ms` });
    }
    const topStrip = drawTopTicks(wctx, W, H, labels);
    clearAndGrid(wctx, W, H, topStrip);

    if (!ring) return;

    const fg = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim();
    const muted = getComputedStyle(document.documentElement).getPropertyValue('--muted').trim();
    const accent = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
    const abACol = getComputedStyle(document.documentElement).getPropertyValue('--abA').trim();
    const abBCol = getComputedStyle(document.documentElement).getPropertyValue('--abB').trim();

    const innerTop = topStrip;
    const innerH = H - innerTop;

    // center line
    wctx.save();
    wctx.strokeStyle = muted;
    wctx.globalAlpha = 0.6;
    wctx.lineWidth = 1;
    wctx.beginPath();
    wctx.moveTo(0, innerTop + innerH/2);
    wctx.lineTo(W, innerTop + innerH/2);
    wctx.stroke();
    wctx.restore();

    // running: min/max per pixel
    // paused: if view <= threshold => full polyline; else min/max
    const zSpan = (waveZoom.t1 - waveZoom.t0);
    const sr = audioCtx ? audioCtx.sampleRate : 48000;
    const pointsInView = Math.max(2, Math.floor(sr * zSpan));
    const FULL_POLY_THRESHOLD = 8000;
    const useFullPolyline = (isPaused && pointsInView <= FULL_POLY_THRESHOLD);

    wctx.save();
    wctx.strokeStyle = fg;
    wctx.lineWidth = 2;

    if (useFullPolyline){
      wctx.beginPath();
      const win = timeWinSec();
      const startIdx = Math.floor((waveZoom.t0 / win) * (ring.length - 1));
      const endIdx   = Math.floor((waveZoom.t1 / win) * (ring.length - 1));
      const spanIdx = Math.max(1, endIdx - startIdx);

      for (let i=0; i<=spanIdx; i++){
        const idxInWindow = startIdx + i;
        const idxRing = (ringWrite + idxInWindow) % ring.length;
        const v = ring[idxRing];
        const x = (i/spanIdx) * W;
        const y = innerTop + (0.5 - v/2) * innerH;
        if (i===0) wctx.moveTo(x,y); else wctx.lineTo(x,y);
      }
      wctx.stroke();
    } else {
      const px = W;
      const win = timeWinSec();
      const startT = waveZoom.t0;
      const endT = waveZoom.t1;
      const spanT = Math.max(1e-9, endT - startT);

      for (let x=0; x<px; x++){
        const frac0 = x / px;
        const frac1 = (x+1) / px;
        const tA = startT + frac0 * spanT;
        const tB = startT + frac1 * spanT;

        const iA = Math.floor((tA / win) * (ring.length - 1));
        const iB = Math.floor((tB / win) * (ring.length - 1));
        const ia = clamp(iA, 0, ring.length-1);
        const ib = clamp(iB, 0, ring.length-1);

        let mn = Infinity, mx = -Infinity;
        for (let i=ia; i<=ib; i++){
          const idxRing = (ringWrite + i) % ring.length;
          const v = ring[idxRing];
          if (v < mn) mn = v;
          if (v > mx) mx = v;
        }
        if (!isFinite(mn) || !isFinite(mx)) continue;

        const y1 = innerTop + (0.5 - mx/2) * innerH;
        const y2 = innerTop + (0.5 - mn/2) * innerH;
        wctx.beginPath();
        wctx.moveTo(x+0.5, y1);
        wctx.lineTo(x+0.5, y2);
        wctx.stroke();
      }
    }
    wctx.restore();

    // cursor/A/B lines only in pause
    if (isPaused && cursorWave){
      const x = waveXFromTime(cursorWave.tSec);
      wctx.save();
      wctx.strokeStyle = accent;
      wctx.lineWidth = 2;
      wctx.globalAlpha = 0.9;
      wctx.beginPath(); wctx.moveTo(x, innerTop); wctx.lineTo(x, H); wctx.stroke();
      wctx.restore();
    }
    if (isPaused && waveAB.A){
      const x = waveXFromTime(waveAB.A.tSec);
      wctx.save(); wctx.strokeStyle = abACol; wctx.lineWidth = 2;
      wctx.beginPath(); wctx.moveTo(x, innerTop); wctx.lineTo(x, H); wctx.stroke();
      wctx.restore();
    }
    if (isPaused && waveAB.B){
      const x = waveXFromTime(waveAB.B.tSec);
      wctx.save(); wctx.strokeStyle = abBCol; wctx.lineWidth = 2;
      wctx.beginPath(); wctx.moveTo(x, innerTop); wctx.lineTo(x, H); wctx.stroke();
      wctx.restore();
    }
  }

  // ========= spectrum =========
  function getFminFmaxClamped(){
    if (!audioCtx) return {fmin: fminHz, fmax: fmaxHz, nyq: 24000};
    const nyq = audioCtx.sampleRate/2;
    const fmin = clamp(fminHz, 0, nyq-1e-6);
    const fmax = clamp(fmaxHz, fmin+1e-6, nyq);
    return {fmin, fmax, nyq};
  }
  function specBinToHz(bin, bins){
    const nyq = audioCtx ? audioCtx.sampleRate/2 : 24000;
    return (bin/(bins-1)) * nyq;
  }
  function specHzToBin(fHz, bins){
    const nyq = audioCtx ? audioCtx.sampleRate/2 : 24000;
    return clamp(Math.round((fHz/nyq)*(bins-1)), 0, bins-1);
  }
  function specXFromHz(fHz){
    const W = specC.width;
    const frac = (fHz - specZoom.f0) / (specZoom.f1 - specZoom.f0);
    return clamp(frac, 0, 1) * W;
  }

  function computeNormSpectrumInZoom(){
    if (!analyser || !audioCtx) return {normArray:new Float32Array(0), hzArray:new Float32Array(0), dbArray:new Float32Array(0)};

    const bins = analyser.frequencyBinCount;
    const dbAll = new Float32Array(bins);
    analyser.getFloatFrequencyData(dbAll);

    snapFreqDb = dbAll;
    snapFreqHz = new Float32Array(bins);
    for (let i=0; i<bins; i++) snapFreqHz[i] = specBinToHz(i, bins);

    const b0 = specHzToBin(specZoom.f0, bins);
    const b1 = specHzToBin(specZoom.f1, bins);
    const lo = Math.min(b0,b1);
    const hi = Math.max(b0,b1);

    const len = Math.max(2, hi - lo + 1);
    const normArray = new Float32Array(len);
    const hzArray = new Float32Array(len);
    const dbArray = new Float32Array(len);

    let maxAmp = 0;
    const ampTmp = new Float32Array(len);

    for (let i=0; i<len; i++){
      const bin = lo + i;
      const db = dbAll[bin];
      const amp = Math.pow(10, db/20);
      ampTmp[i] = amp;
      if (amp > maxAmp) maxAmp = amp;
      hzArray[i] = snapFreqHz[bin];
      dbArray[i] = db;
    }
    if (maxAmp <= 0) maxAmp = 1;
    for (let i=0; i<len; i++) normArray[i] = (ampTmp[i]/maxAmp) * 100;

    let bestI = 0, bestN = -Infinity;
    for (let i=0; i<len; i++){
      if (normArray[i] > bestN){ bestN = normArray[i]; bestI = i; }
    }
    peak = { fHz: hzArray[bestI], norm: normArray[bestI], db: dbArray[bestI] };

    return {normArray, hzArray, dbArray};
  }

  function specValueAt(canvasX){
    if (!snapFreqDb || !snapFreqHz || !audioCtx) return null;
    const W = specC.width;
    const frac = clamp(canvasX / W, 0, 1);
    const f = specZoom.f0 + frac * (specZoom.f1 - specZoom.f0);

    const bins = snapFreqDb.length;
    const bin = specHzToBin(f, bins);
    const db = snapFreqDb[bin];

    const {normArray, hzArray} = computeNormSpectrumInZoom();
    const i = clamp(Math.round(frac * (normArray.length-1)), 0, normArray.length-1);
    return { fHz: hzArray[i], norm: normArray[i], db };
  }

  function drawSpec(){
    const W = specC.width, H = specC.height;
    const nTicks = tickCountForWidth(W / (window.devicePixelRatio || 1));

    const f0 = specZoom.f0, f1 = specZoom.f1;
    const labels = [];
    for (let i=0; i<nTicks; i++){
      const frac = (nTicks === 1) ? 0 : (i/(nTicks-1));
      const f = f0 + frac*(f1-f0);
      const text = (f >= 1000) ? `${(f/1000).toFixed(f<10000?1:0)}k` : `${Math.round(f)}`;
      labels.push({ x: frac*W, text: `${text} Hz` });
    }
    const topStrip = drawTopTicks(sctx, W, H, labels);
    clearAndGrid(sctx, W, H, topStrip);

    if (!analyser || !audioCtx) return;

    const fg = getComputedStyle(document.documentElement).getPropertyValue('--fg').trim();
    const peakCol = getComputedStyle(document.documentElement).getPropertyValue('--peak').trim();
    const accent = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
    const abACol = getComputedStyle(document.documentElement).getPropertyValue('--abA').trim();
    const abBCol = getComputedStyle(document.documentElement).getPropertyValue('--abB').trim();
    const muted = getComputedStyle(document.documentElement).getPropertyValue('--muted').trim();

    const innerTop = topStrip;
    const innerH = H - innerTop;

    const {normArray} = computeNormSpectrumInZoom();
    if (normArray.length < 2) return;

    sctx.save();
    sctx.strokeStyle = fg;
    sctx.lineWidth = 2;
    sctx.beginPath();
    for (let i=0; i<normArray.length; i++){
      const x = (i/(normArray.length-1)) * W;
      const y = innerTop + (1 - clamp(normArray[i]/100, 0, 1)) * innerH;
      if (i===0) sctx.moveTo(x,y); else sctx.lineTo(x,y);
    }
    sctx.stroke();
    sctx.restore();

    sctx.save();
    sctx.fillStyle = muted;
    sctx.font = '12px system-ui';
    sctx.fillText('100%', 6, innerTop + 14);
    sctx.fillText('0%', 6, H - 8);
    sctx.restore();

    if (peak){
      const x = specXFromHz(peak.fHz);

      sctx.save();
      sctx.strokeStyle = peakCol;
      sctx.lineWidth = 2;
      sctx.beginPath(); sctx.moveTo(x, innerTop); sctx.lineTo(x, H); sctx.stroke();

      sctx.fillStyle = peakCol;
      sctx.font = '12px system-ui';
      const txt = `PEAK ${peak.fHz.toFixed(1)} Hz`;
      const y = Math.round(innerTop * 0.88);
      const tw = sctx.measureText(txt).width;
      const xx = clamp(x - tw/2, 2, W - tw - 2);
      sctx.fillText(txt, xx, y);
      sctx.restore();
    }

    if (isPaused && cursorSpec){
      const x = specXFromHz(cursorSpec.fHz);
      sctx.save();
      sctx.strokeStyle = accent;
      sctx.lineWidth = 2;
      sctx.globalAlpha = 0.9;
      sctx.beginPath(); sctx.moveTo(x, innerTop); sctx.lineTo(x, H); sctx.stroke();
      sctx.restore();
    }

    if (isPaused && specAB.A){
      const x = specXFromHz(specAB.A.fHz);
      sctx.save(); sctx.strokeStyle = abACol; sctx.lineWidth = 2;
      sctx.beginPath(); sctx.moveTo(x, innerTop); sctx.lineTo(x, H); sctx.stroke();
      sctx.restore();
    }
    if (isPaused && specAB.B){
      const x = specXFromHz(specAB.B.fHz);
      sctx.save(); sctx.strokeStyle = abBCol; sctx.lineWidth = 2;
      sctx.beginPath(); sctx.moveTo(x, innerTop); sctx.lineTo(x, H); sctx.stroke();
      sctx.restore();
    }
  }

  // ========= Δ =========
  function updateDelta(){
    if (waveAB.A && waveAB.B){
      const dt = (waveAB.B.tSec - waveAB.A.tSec);
      const da = (waveAB.B.amp - waveAB.A.amp);
      deltaWave.textContent =
`Δt = ${(dt*1000).toFixed(3)} ms
Δamp = ${da.toFixed(4)}
A: ${Math.round(waveAB.A.tSec*1000)} ms / ${waveAB.A.amp.toFixed(4)}
B: ${Math.round(waveAB.B.tSec*1000)} ms / ${waveAB.B.amp.toFixed(4)}`;
    } else if (waveAB.A || waveAB.B){
      const p = waveAB.B || waveAB.A;
      deltaWave.textContent =
`A/Bをもう1点選ぶとΔを表示します
選択中: ${Math.round(p.tSec*1000)} ms / ${p.amp.toFixed(4)}`;
    } else {
      deltaWave.innerHTML = `<small>Δ（波形）：Pause中にA/Bを選択すると表示されます</small>`;
    }

    if (specAB.A && specAB.B){
      const df = (specAB.B.fHz - specAB.A.fHz);
      const dn = (specAB.B.norm - specAB.A.norm);
      const ddb = (specAB.B.db - specAB.A.db);
      deltaSpec.textContent =
`Δf = ${df.toFixed(1)} Hz
Δ(正規化) = ${dn.toFixed(2)} %
ΔdB = ${ddb.toFixed(2)} dB
A: ${specAB.A.fHz.toFixed(1)} Hz / ${specAB.A.norm.toFixed(2)}% / ${specAB.A.db.toFixed(1)} dB
B: ${specAB.B.fHz.toFixed(1)} Hz / ${specAB.B.norm.toFixed(2)}% / ${specAB.B.db.toFixed(1)} dB`;
    } else if (specAB.A || specAB.B){
      const p = specAB.B || specAB.A;
      deltaSpec.textContent =
`A/Bをもう1点選ぶとΔを表示します
選択中: ${p.fHz.toFixed(1)} Hz / ${p.norm.toFixed(2)}% / ${p.db.toFixed(1)} dB`;
    } else {
      deltaSpec.innerHTML = `<small>Δ（音響スペクトル）：Pause中にA/Bを選択すると表示されます</small>`;
    }
  }

  // ========= loop =========
  function updateRingFromAnalyser(){
    if (!analyser || !ring) return;
    const n = analyser.fftSize;
    const tmp = new Float32Array(n);
    analyser.getFloatTimeDomainData(tmp);
    for (let i=0; i<n; i++){
      ring[ringWrite] = tmp[i];
      ringWrite = (ringWrite + 1) % ring.length;
    }
  }

  function loop(){
    if (!isRunning || isPaused) return;
    updateRingFromAnalyser();
    drawWave();
    drawSpec();
    setStatus();
    rafId = requestAnimationFrame(loop);
  }

  function redrawAll(){
    drawWave();
    drawSpec();
    updateDelta();
    setStatus();
  }

  // ========= Start / Pause / Reset(=Stop) =========
  async function start(){
    if (isRunning) return;

    stream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false }
    });

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = parseInt(fftS.value, 10);
    analyser.smoothingTimeConstant = 0.2;

    src = audioCtx.createMediaStreamSource(stream);
    src.connect(analyser);

    snapSR = audioCtx.sampleRate;
    snapFFT = analyser.fftSize;
    srPill.textContent = `sampleRate: ${snapSR} Hz`;

    allocRing();
    waveZoom = {t0:0, t1: timeWinSec()};

    // spectrum base range
    specZoom = {f0: fminHz, f1: fmaxHz};

    isRunning = true;
    isPaused = false;

    waveAB = {A:null, B:null};
    specAB = {A:null, B:null};
    cursorWave = null;
    cursorSpec = null;
    peak = null;

    applyButtonStates();
    redrawAll();

    if (rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(loop);
  }

  function pause(){
    if (!isRunning || isPaused) return;
    isPaused = true;

    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;

    // snapshot waveform
    if (ring){
      const n = ring.length;
      snapWave = new Float32Array(n);
      for (let i=0; i<n; i++){
        const idx = (ringWrite + i) % n;
        snapWave[i] = ring[idx];
      }
    }
    snapSR = audioCtx.sampleRate;
    snapFFT = analyser.fftSize;

    applyButtonStates();
    redrawAll();
  }

  function resume(){
    if (!isRunning || !isPaused) return;
    isPaused = false;

    cursorWave = null;
    cursorSpec = null;

    applyButtonStates();
    redrawAll();

    if (rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(loop);
  }

  function resetAll(){
    // Reset = Stop + full init
    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;

    if (stream){
      stream.getTracks().forEach(t => t.stop());
      stream = null;
    }
    if (audioCtx){
      audioCtx.close();
      audioCtx = null;
    }
    analyser = null;
    src = null;

    isRunning = false;
    isPaused = false;

    ring = null;
    ringWrite = 0;

    snapWave = null;
    snapFreqDb = null;
    snapFreqHz = null;

    cursorWave = null;
    cursorSpec = null;
    peak = null;

    waveAB = {A:null, B:null};
    specAB = {A:null, B:null};

    waveZoom = {t0:0, t1: timeWinSec()};
    specZoom = {f0: fminHz, f1: fmaxHz};

    srPill.textContent = 'sampleRate: -';

    applyButtonStates();
    redrawAll();
  }

  // ========= UI =========
  btnStart.addEventListener('click', async () => {
    try{ await start(); }
    catch(e){
      console.error(e);
      alert('マイクの許可が必要です（HTTPS で開いてください）。');
    }
  });

  btnPause.addEventListener('click', () => {
    if (!isRunning) return;
    if (!isPaused) pause();
    else resume();
  });

  btnReset.addEventListener('click', resetAll);

  btnTheme.addEventListener('click', () => {
    const dark = document.documentElement.dataset.theme !== 'dark';
    setTheme(dark);
    redrawAll();
  });

  tabBoth.addEventListener('click', () => setActiveTab('both'));
  tabWave.addEventListener('click', () => setActiveTab('wave'));
  tabSpec.addEventListener('click', () => setActiveTab('spec'));

  btnMode.addEventListener('click', () => setMode(mode === 'zoom' ? 'ab' : 'zoom'));

  btnZoomReset.addEventListener('click', () => {
    if (!isPaused) return;
    waveZoom = {t0:0, t1: timeWinSec()};
    specZoom = {f0: fminHz, f1: fmaxHz};
    cursorWave = null;
    cursorSpec = null;
    redrawAll();
  });

  btnResetABWave.addEventListener('click', () => {
    if (!isPaused) return;
    waveAB = {A:null, B:null};
    updateDelta();
    redrawAll();
  });

  btnResetABSpec.addEventListener('click', () => {
    if (!isPaused) return;
    specAB = {A:null, B:null};
    updateDelta();
    redrawAll();
  });

  // Wave window sync
  function setTimeWin(v){
    const vv = clamp(parseFloat(v), 0.05, 5);
    secRange.value = vv.toFixed(2);
    secNum.value = vv.toFixed(2);
    if (isRunning){
      allocRing();
      waveZoom = {t0:0, t1: timeWinSec()};
      waveAB = {A:null, B:null};
      cursorWave = null;
      updateDelta();
    }
    redrawAll();
  }
  secRange.addEventListener('input', () => setTimeWin(secRange.value));
  secNum.addEventListener('change', () => setTimeWin(secNum.value));

  fftS.addEventListener('change', () => {
    if (!analyser) return;
    analyser.fftSize = parseInt(fftS.value, 10);
    snapFFT = analyser.fftSize;
    redrawAll();
  });

  function setFminUI(){
    const v = fminPreset.value;
    if (v === '任意'){
      fminCustom.classList.remove('hidden');
      fminHz = clamp(parseFloat(fminCustom.value || "0"), 0, 1e9);
    } else {
      fminCustom.classList.add('hidden');
      fminHz = parseFloat(v);
      fminCustom.value = String(fminHz);
    }
  }
  function setFmaxUI(){
    const v = fmaxPreset.value;
    if (v === '任意'){
      fmaxCustom.classList.remove('hidden');
      fmaxHz = clamp(parseFloat(fmaxCustom.value || "1500"), 1, 1e9);
    } else {
      fmaxCustom.classList.add('hidden');
      fmaxHz = parseFloat(v);
      fmaxCustom.value = String(fmaxHz);
    }
  }
  function applySpecRange(){
    if (audioCtx){
      const {fmin, fmax} = getFminFmaxClamped();
      fminHz = fmin; fmaxHz = fmax;
    }
    specZoom = {f0: fminHz, f1: fmaxHz};
    specAB = {A:null, B:null};
    cursorSpec = null;
    updateDelta();
    redrawAll();
  }
  fminPreset.addEventListener('change', () => { setFminUI(); applySpecRange(); });
  fmaxPreset.addEventListener('change', () => { setFmaxUI(); applySpecRange(); });
  fminCustom.addEventListener('change', () => { setFminUI(); applySpecRange(); });
  fmaxCustom.addEventListener('change', () => { setFmaxUI(); applySpecRange(); });

  setFminUI(); setFmaxUI(); applySpecRange();

  // ========= pointer helpers =========
  function canvasX(canvas, ev){
    const r = canvas.getBoundingClientRect();
    const x = (ev.clientX - r.left) * (canvas.width / r.width);
    return clamp(x, 0, canvas.width);
  }

  // ========= Zoom (Pause only) =========
  function makeZoomHandlers(canvas, kind){
    let dragging = false;
    let dragStartX = 0;
    let dragLastX = 0;
    let dragIsPan = false;

    let lastDist = 0;
    let lastMidX = 0;

    function getRange(){
      return (kind === 'wave') ? {a: waveZoom.t0, b: waveZoom.t1} : {a: specZoom.f0, b: specZoom.f1};
    }
    function setRange(a,b){
      if (kind === 'wave'){
        const win = timeWinSec();
        const na = clamp(Math.min(a,b), 0, win);
        const nb = clamp(Math.max(a,b), 0, win);
        const minSpan = win * 0.002;
        if ((nb-na) < minSpan) return;
        waveZoom = {t0:na, t1:nb};
      } else {
        const base0 = fminHz, base1 = fmaxHz;
        const na = clamp(Math.min(a,b), base0, base1);
        const nb = clamp(Math.max(a,b), base0, base1);
        const minSpan = Math.max(1, (base1-base0)*0.002);
        if ((nb-na) < minSpan) return;
        specZoom = {f0:na, f1:nb};
      }
    }
    function mapXToValue(x){
      const W = canvas.width;
      const frac = clamp(x/W, 0, 1);
      const r = getRange();
      return r.a + frac*(r.b - r.a);
    }
    function panBy(dx){
      const W = canvas.width;
      const r = getRange();
      const span = (r.b - r.a);
      const dv = -(dx/W) * span;
      setRange(r.a + dv, r.b + dv);
    }

    canvas.addEventListener('pointermove', (ev) => {
      if (!isPaused || !audioCtx) return;

      const x = canvasX(canvas, ev);
      if (kind === 'wave') cursorWave = waveValueAt(x);
      else cursorSpec = specValueAt(x);
      setStatus();

      if (!dragging || mode !== 'zoom') return;

      dragLastX = x;
      if (dragIsPan){
        panBy(dragLastX - dragStartX);
        dragStartX = dragLastX;
        redrawAll();
      }
    });

    canvas.addEventListener('pointerdown', (ev) => {
      if (!isPaused || !audioCtx) return;
      if (mode !== 'zoom') return;

      dragging = true;
      dragStartX = canvasX(canvas, ev);
      dragLastX = dragStartX;
      dragIsPan = ev.shiftKey === true;
      canvas.setPointerCapture(ev.pointerId);
    });

    canvas.addEventListener('pointerup', (ev) => {
      if (!dragging) return;
      if (!isPaused || !audioCtx) { dragging = false; return; }
      if (mode !== 'zoom') { dragging = false; return; }

      const endX = canvasX(canvas, ev);
      dragging = false;

      if (dragIsPan){ redrawAll(); return; }

      if (Math.abs(endX - dragStartX) < 6){ redrawAll(); return; }
      const v0 = mapXToValue(dragStartX);
      const v1 = mapXToValue(endX);
      setRange(v0, v1);
      redrawAll();
    });

    canvas.addEventListener('dblclick', () => {
      if (!isPaused) return;
      if (kind === 'wave') waveZoom = {t0:0, t1: timeWinSec()};
      else specZoom = {f0: fminHz, f1: fmaxHz};
      redrawAll();
    });

    // touch pinch + 2 finger pan
    canvas.addEventListener('touchstart', (ev) => {
      if (!isPaused || !audioCtx) return;
      if (mode !== 'zoom') return;
      if (ev.touches.length === 2){
        ev.preventDefault();
        const t0 = ev.touches[0], t1 = ev.touches[1];
        const r = canvas.getBoundingClientRect();
        const x0 = (t0.clientX - r.left) * (canvas.width / r.width);
        const x1 = (t1.clientX - r.left) * (canvas.width / r.width);
        lastDist = Math.abs(x1 - x0);
        lastMidX = (x0 + x1) / 2;
      }
    }, {passive:false});

    canvas.addEventListener('touchmove', (ev) => {
      if (!isPaused || !audioCtx) return;
      if (mode !== 'zoom') return;
      if (ev.touches.length === 2){
        ev.preventDefault();
        const t0 = ev.touches[0], t1 = ev.touches[1];
        const r = canvas.getBoundingClientRect();
        const x0 = (t0.clientX - r.left) * (canvas.width / r.width);
        const x1 = (t1.clientX - r.left) * (canvas.width / r.width);
        const dist = Math.abs(x1 - x0);
        const midX = (x0 + x1) / 2;

        const panDx = (midX - lastMidX);
        if (Math.abs(panDx) > 0.5) panBy(panDx);
        lastMidX = midX;

        if (lastDist > 0){
          const scale = dist / lastDist;
          const r0 = getRange();
          const midV = mapXToValue(midX);
          const span = (r0.b - r0.a) / scale;
          const a = midV - (midV - r0.a) / scale;
          const b = a + span;
          setRange(a, b);
        }
        lastDist = dist;

        redrawAll();
      }
    }, {passive:false});
  }

  makeZoomHandlers(waveC, 'wave');
  makeZoomHandlers(specC, 'spec');

  // ========= AB selection (Pause only) =========
  function makeABHandlers(canvas, kind){
    canvas.addEventListener('pointerdown', (ev) => {
      if (!isPaused || !audioCtx) return;
      if (mode !== 'ab') return;

      const x = canvasX(canvas, ev);
      if (kind === 'wave'){
        const v = waveValueAt(x);
        if (!v) return;
        if (!waveAB.A) waveAB.A = v;
        else if (!waveAB.B) waveAB.B = v;
        else waveAB = {A:v, B:null};
      } else {
        const v = specValueAt(x);
        if (!v) return;
        if (!specAB.A) specAB.A = v;
        else if (!specAB.B) specAB.B = v;
        else specAB = {A:v, B:null};
      }
      updateDelta();
      redrawAll();
    });
  }
  makeABHandlers(waveC, 'wave');
  makeABHandlers(specC, 'spec');

  // ========= CSV DL (Pause only) =========
  function downloadCSV(){
    if (!isPaused || !audioCtx) return;

    const lines = [];
    lines.push(`# Mic Waveform + Acoustic Spectrum CSV`);
    lines.push(`# sampleRate=${snapSR}, fftSize=${snapFFT}`);
    lines.push(`# timeWindowSec=${timeWinSec().toFixed(3)}`);
    lines.push(`# waveZoom=[${waveZoom.t0.toFixed(6)}, ${waveZoom.t1.toFixed(6)}] sec`);
    lines.push(`# specZoom=[${specZoom.f0.toFixed(3)}, ${specZoom.f1.toFixed(3)}] Hz`);
    lines.push('');

    if (snapWave){
      lines.push('WAVEFORM');
      lines.push('t_ms,amp');
      const win = timeWinSec();
      const n = snapWave.length;
      for (let i=0; i<n; i++){
        const t = (i/(n-1)) * win * 1000;
        lines.push(`${t.toFixed(6)},${snapWave[i].toFixed(8)}`);
      }
      lines.push('');
    }

    if (snapFreqDb && snapFreqHz){
      lines.push('SPECTRUM');
      lines.push('f_hz,db,norm_percent');

      const bins = snapFreqDb.length;
      const b0 = specHzToBin(specZoom.f0, bins);
      const b1 = specHzToBin(specZoom.f1, bins);
      const lo = Math.min(b0,b1), hi = Math.max(b0,b1);

      let maxAmp = 0;
      const amp = new Float64Array(hi-lo+1);
      for (let i=lo; i<=hi; i++){
        const a = Math.pow(10, snapFreqDb[i]/20);
        amp[i-lo] = a;
        if (a > maxAmp) maxAmp = a;
      }
      if (maxAmp <= 0) maxAmp = 1;

      for (let i=lo; i<=hi; i++){
        const f = snapFreqHz[i];
        const db = snapFreqDb[i];
        const norm = (amp[i-lo]/maxAmp)*100;
        lines.push(`${f.toFixed(3)},${db.toFixed(3)},${norm.toFixed(4)}`);
      }
    }

    const blob = new Blob([lines.join('\n')], {type:'text/csv;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const ts = new Date();
    const name = `mic_wave_spec_${ts.getFullYear()}-${String(ts.getMonth()+1).padStart(2,'0')}-${String(ts.getDate()).padStart(2,'0')}_${String(ts.getHours()).padStart(2,'0')}${String(ts.getMinutes()).padStart(2,'0')}${String(ts.getSeconds()).padStart(2,'0')}.csv`;
    a.href = url;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }
  btnCSV.addEventListener('click', downloadCSV);

  // ========= Shortcuts =========
  function isTypingTarget(el){
    if (!el) return false;
    const tag = (el.tagName || '').toLowerCase();
    if (tag === 'input' || tag === 'textarea' || tag === 'select') return true;
    if (el.isContentEditable) return true;
    return false;
  }

  window.addEventListener('keydown', (ev) => {
    if (ev.repeat) return;
    if (isTypingTarget(document.activeElement)) return;

    const k = (ev.key || '').toLowerCase();

    // avoid interfering with browser shortcuts
    if (ev.metaKey || ev.ctrlKey || ev.altKey) return;

    if (k === 's'){
      ev.preventDefault();
      if (!isRunning) btnStart.click();
      return;
    }
    if (k === 'p'){
      ev.preventDefault();
      if (isRunning) btnPause.click();
      return;
    }
    if (k === 'r'){
      ev.preventDefault();
      if (isRunning) btnReset.click();
      return;
    }
    if (k === 'z'){
      ev.preventDefault();
      btnMode.click();
      return;
    }
    if (k === 'w'){ ev.preventDefault(); tabWave.click(); return; }
    if (k === 'f'){ ev.preventDefault(); tabSpec.click(); return; }
    if (k === 'b'){ ev.preventDefault(); tabBoth.click(); return; }

    if (k === 'v'){
      ev.preventDefault();
      if (isPaused) downloadCSV();
      return;
    }

    if (k === 'escape'){
      ev.preventDefault();
      if (!isPaused) return;
      cursorWave = null;
      cursorSpec = null;
      waveAB = {A:null, B:null};
      specAB = {A:null, B:null};
      updateDelta();
      redrawAll();
      return;
    }
  });

  // ========= Init =========
  resizeAll();
  setActiveTab('both');
  applyButtonStates();
  redrawAll();

})();
</script>
</body>
</html>
